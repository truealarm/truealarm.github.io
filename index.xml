<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>True Alarm</title>
        <link>https://truealarm.github.io/</link>
        <description>Recent content on True Alarm</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 27 Jan 2023 21:05:32 +0900</lastBuildDate><atom:link href="https://truealarm.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Cycle detection in a sequence</title>
        <link>https://truealarm.github.io/p/cycle-detection-in-a-sequence/</link>
        <pubDate>Fri, 27 Jan 2023 21:05:32 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/cycle-detection-in-a-sequence/</guid>
        <description>&lt;p&gt;이번 포스트는 LeetCode에서 단순 연결 리스트(Single linked list)에 순환(cycle)이 존재하는지 찾는 문제를 풀며 배운 cycle detection 알고리즘을 다룬다. 이와 관련해서 풀었던 문제 목록은 아래 적어두었으니 처음 보는 문제라면 먼저 풀어보는 것을 추천한다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/linked-list-cycle/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linked List Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/linked-list-cycle-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linked List Cycle II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어떤 방식으로든 문제를 해결했다면 다른 사람의 풀이랑 시간, 공간 복잡도를 비교하는 과정을 통해 내가 작성한 코드보다 효율적인 알고리즘을 배울 수 있다. 그 중 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Cycle_detection&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cycle detection&lt;/a&gt; 위키에 아주 상세히 나와있는 Floyd&amp;rsquo;s cycle-finding algorithm과 Brent&amp;rsquo;s algorithm에 대해 정리해보았다.&lt;/p&gt;
&lt;h2 id=&#34;definitions&#34;&gt;Definitions&lt;/h2&gt;
&lt;p&gt;앞으로 나올 알고리즘을 쉽게 이해하기 위해, 싱글 링크드 리스트에서 순환을 찾는 문제를 수학적으로 표현하면 다음과 같다. 유한 집합 S에 속하는 함수 f에 대해, 초기값 x&lt;sub&gt;0&lt;/sub&gt;부터 iterated function에 대입하여 얻은 sequence에서 x&lt;sub&gt;i&lt;/sub&gt; = x&lt;sub&gt;j&lt;/sub&gt; 를 만족하는 서로 다른 i, j가 존재하면, x&lt;sub&gt;i&lt;/sub&gt; ~ x&lt;sub&gt;j-1&lt;/sub&gt;가 주기적으로 반복됨을 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x&lt;sub&gt;0&lt;/sub&gt;,  x&lt;sub&gt;1&lt;/sub&gt;  =  f(x&lt;sub&gt;0&lt;/sub&gt;), x&lt;sub&gt;2&lt;/sub&gt; = f(x&lt;sub&gt;1&lt;/sub&gt;), &amp;hellip; , x&lt;sub&gt;i&lt;/sub&gt; = f(x&lt;sub&gt;i-1&lt;/sub&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반복적으로 계속 나타나는 sequence 중 가장 작은 인덱스 &lt;em&gt;μ&lt;/em&gt;와 x&lt;sub&gt;μ&lt;/sub&gt; = x&lt;sub&gt;λ + μ&lt;/sub&gt;를 만족하는 가장 작은 λ를 찾는게 Cycle dection algorithm의 핵심이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;μ : 순환이 처음 시작되는 위치의 인덱스&lt;/li&gt;
&lt;li&gt;λ : 순환의 주기&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;📝 &lt;strong&gt;Note : Iterated function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Iterated function은 &lt;em&gt;f&lt;/em&gt; : &lt;em&gt;X&lt;/em&gt; → &lt;em&gt;X&lt;/em&gt; 인 함수 그 자체를 반복적으로 합성한 함수이다. 이는 임의의 초기 값의 출력을 다시 입력으로 넣는 과정을 여러번 반복하는 함수를 의미한다.&lt;/p&gt;
&lt;p&gt;Ref: &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Iterated_function&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Iterated_function&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;naive-algorithm&#34;&gt;Naive algorithm&lt;/h2&gt;
&lt;p&gt;가장 쉽게 구현할 수 있는 Cycle detection 알고리즘은 순환 주기에 속한 요소는 반복적으로 나타나는 특성을 이용하는 것이다. sequence가 종료되기 전까지 계속 x&lt;sub&gt;i&lt;/sub&gt;를 키로 i 값을 해시 테이블에 저장하고, 이미 저장된 요소인지 확인한다. 이미 저장된 요소가 발견되면 순환이 존재하는 것이고, 이 요소는 순환이 처음 시작되는 위치에서 한번 순환 주기를 돌아 다시 나타난 요소이다. 따라서 인덱스는 μ+λ 일테니 해시 테이블에 이미 저장되어 있는 μ 값을 통해 λ을 구하면 된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;naive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hashTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hashTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;# there is no cycle&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hashTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;해시 테이블의 연산 속도를 O(1)이라고 하면 시간복잡도는 O(μ+λ)가 되고, 공간복잡도도 해시 테이블이 사용하는 만큼인 O(μ+λ)가 된다. 단방향 sequence에서 순환을 탐지하는데 걸리는 시간이 μ+λ에 비례하는 것은 충분히 합리적이지만, 공간복잡도도 μ+λ에 비례해서 커지는 것은 비효율적이다. 또한 μ+λ가 충분히 커지면 해시 테이블에 충돌이 발생할 수 있어 시간복잡도가 quadratic time이 될 수 있다. 이러한 단점을 극복하여 보다 적은 메모리를 사용하고, 함수 f의 호출 횟수나 연산 횟수를 줄여 시간을 단축시킬 수 있도록 고안된 게 Cycle detection 알고리즘이다.&lt;/p&gt;
&lt;h2 id=&#34;floyds-cycle-finding-algorithm&#34;&gt;Floyd&amp;rsquo;s cycle-finding algorithm&lt;/h2&gt;
&lt;p&gt;Floyd&amp;rsquo;s cycle-finding algorithm은 두 개의 포인터를 서로 다른 속도로 sequence를 반복하며 순환을 찾아 &amp;ldquo;tortoise and the hare algorithm&amp;quot;이라고도 불린다. 토끼와 거북이 우화와 토끼는 거북이에게 결국 역전당하지만, 이 알고리즘에서 totoise과 hare는 hare가 항상 앞서 간다는 의미로 사용된다. 여담으로 이 알고리즘을 캡틴 아메리카의 명대사인 &amp;ldquo;on your left&amp;quot;라고 표현한 LeetCode 베스트 댓글을 보고 더욱 잘 와닿았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://truealarm.github.io/p/cycle-detection-in-a-sequence/captain.jpeg&#34;
	width=&#34;1280&#34;
	height=&#34;720&#34;
	srcset=&#34;https://truealarm.github.io/p/cycle-detection-in-a-sequence/captain_hucc4227c0d034aa4191bb76c2f8622ceb_157050_480x0_resize_q75_box.jpeg 480w, https://truealarm.github.io/p/cycle-detection-in-a-sequence/captain_hucc4227c0d034aa4191bb76c2f8622ceb_157050_1024x0_resize_q75_box.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;캡틴 아메리카: 윈터솔저 명장면&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;본론으로 돌아와서 Floyd&amp;rsquo;s cycle-finding algorithm의 핵심 인사이트는 다음과 같다. 1번씩 진행되는 포인터(tortoise)와 2번씩 진행되는 포인터(hare)를 반복적으로 진행하면, tortoise와 hare의 거리가 1씩 벌어지게 된다. 순환이 존재한다면 두 포인터 모두 순환에 빠지게 될테고, 거리가 1씩 벌어지다 결국 hare가 tortoise를 앞지르게 될 것이다.&lt;/p&gt;
&lt;p&gt;반복되는 sequence 길이인 순환의 크기를 λ라고 할 때 tortoise와 hare가 움직인 거리 차이는 kλ (k&amp;gt;=0)이다. hare의 이동 거리는 totorise의 2배이므로 거리 차이는 tortoise가 움직인 거리와 같다. 결국 tortoise의 현재 위치 v는 kλ가 된다.&lt;/p&gt;
&lt;p&gt;이를 수학적으로 다시 정리하면 다음과 같다. 순환의 시작점을 μ라고 할 때 μ보다 큰 임의의 인덱스 i에 대해 x&lt;sub&gt;i&lt;/sub&gt; = x&lt;sub&gt;i + kλ&lt;/sub&gt;를 만족하므로, x&lt;sub&gt;i&lt;/sub&gt; = x&lt;sub&gt;2i&lt;/sub&gt;를 만족하려면 i=kλ이여야 한다. x&lt;sub&gt;i&lt;/sub&gt; = x&lt;sub&gt;2i&lt;/sub&gt; 식이 의미하는 대로 1번씩 진행되는 포인터(tortoise)와 2번씩 진행되는 포인터(hare)를 i=0부터 반복하면 i=v=kλ에서 같은 위치에서 같아지게 되는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://truealarm.github.io/p/cycle-detection-in-a-sequence/floyd.png&#34;
	width=&#34;1124&#34;
	height=&#34;640&#34;
	srcset=&#34;https://truealarm.github.io/p/cycle-detection-in-a-sequence/floyd_hucb5a5bee77e845a52196db80c0f0108f_35941_480x0_resize_box_3.png 480w, https://truealarm.github.io/p/cycle-detection-in-a-sequence/floyd_hucb5a5bee77e845a52196db80c0f0108f_35941_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;tortoise와 hare가 만난 지점 v&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;175&#34;
		data-flex-basis=&#34;421px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;두 포인터가 만난 인덱스 v에서 tortoise 포인터만 다시 시작점(i=0)으로 되돌린 후, 두 개의 포인터를 동시에 1번씩 진행하다 보면 같아지는 순간이 찾아오고, 그 지점이 바로 순환의 시작점(μ)이 된다. 왜 그럴 수 밖에 없는지 수식으로도 증명할 수 있지만, 직관적으로 이해하는게 좀 더 와닿을 것이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;v에서 λ의 배수만큼 진행하면 다시 v 위치로 돌아온다.&lt;/li&gt;
&lt;li&gt;v는 λ의 배수이므로, i=0인 지점에서 λ의 배수만큼 진행하다 보면 v 위치로 이동하게 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이는 i=0로 이동한 tortoise 포인터와 v에 위치한 hare 포인터가 같은 속도로 진행하는 상황이라면, v에서 다시 만나게 됨을 의미한다. 같은 속도로 진행하는 두 포인터가 순환 내 같은 위치에서 만난다는 것은, 순환에 진입한 순간부터 계속 같이 움직인다는 것이므로 두 포인터가 처음으로 같아질 때 까지의 진행 횟수를 구하면 μ가 된다 [A].  μ를 구했다면 x&lt;sub&gt;μ&lt;/sub&gt;부터 반복하면서 x&lt;sub&gt;μ&lt;/sub&gt;와 같은 값인 x&lt;sub&gt;μ+λ&lt;/sub&gt;가 나올 때 까지의 진행 횟수를 구하면 순환의 크기인 λ가 된다 [B].&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;floyd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# [A]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 		
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# [B]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;v를 구하는 1번째 반복문에서 kλ만큼 반복, μ를 구하는 2번째 반복문은 μ만큼 반복, λ를 구하는 3번째 반복문에서 λ만큼 반복하므로 Floyd&amp;rsquo;s cycle-finding algorithm의 시간복잡도는 O(μ+λ), 공간복잡도는 O(1)이다&lt;/p&gt;
&lt;h2 id=&#34;brents-algorithm&#34;&gt;Brent&amp;rsquo;s algorithm&lt;/h2&gt;
&lt;p&gt;Brent&amp;rsquo;s algorithm도 Floyd&amp;rsquo;s cycle-finding algorithm과 비슷하게 두 개의 포인터를 서로 다른 속도로 sequence를 반복하며 순환을 찾는다. Brent&amp;rsquo;s algorithm은 hare 포인터의 진행 속도가 2의 거듭 제곱(2&lt;sup&gt;i&lt;/sup&gt;)으로 계속 늘어나며, tortoise 포인터는 진행하지 않고 hare 포인터가 거듭 제곱만큼 진행을 마친 값 x&lt;sub&gt;2&lt;sup&gt;i&lt;/sup&gt;-1&lt;/sub&gt;을 대입한다. 순환이 존재한다면 i가 커짐에 따라 tortoise 포인터는 순환 내부로 들어가게 될테고, 2&lt;sup&gt;i&lt;/sup&gt;가 λ보다 커져 hare 포인터의 진행 과정에서 두 개의 포인터가 같아지는 경우가 발생하게 된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;brent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# [A]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# [A]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# [B]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tortoise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;μ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;λ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;두 개의 포인터가 같아질 때 까지 hare 포인터가 진행한 횟수를 계산하면 순환의 크기(λ)를 바로 알아낼 수 있다 [A]. 순환의 크기를 알아냈다면 두 개의 포인터를 시작점인 i=0으로 되돌린 상태에서 hare 포인터만 λ만큼 진행한다. 그러면 두 개의 포인터의 거리 차이가 순환의 크기와 같아지므로, 이 상태에서 같은 속도로 1번씩 진행하며 처음 같아질 때 까지의 진행 횟수를 구하면 μ를 알 수 있다.&lt;/p&gt;
&lt;p&gt;Brent&amp;rsquo;s algorithm은 iterated function 호출 횟수가 3번인 Floyd&amp;rsquo;s cycle-finding algorithm보다 훨씬 적게 1번만 호출하는 장점이 있고, λ를 곧바로 구할 수 있어 λ, μ를 구하는 과정이 더 단순하다. 싱글 링크드 리스트에서 iterated function은 포인터 연산을 통해 next 주소를 구하는 연산을 수행하므로 함수 호출 횟수가 줄어들수록 성능은 올라간다. 그래서 Floyd&amp;rsquo;s cycle-finding algorithm보다 보통 36% 정도 빠른 벤치마크 성능을 갖는다고 한다.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;이번 포스트에서는 iterated function을 통해 생성한 sequence 내 순환을 찾는 알고리즘을 살펴봤다. Floyd&amp;rsquo;s cycle-finding algorithm과 Brent&amp;rsquo;s algorithm 모두 투 포인터 알고리즘을 통해 O(n)의 시간복잡도와 O(1)의 공간복잡도로 순환을 찾을 수 있었다. 알고리즘에 들어간 핵심 아이디어는 복잡하지 않는데, 나는 왜 처음 LeetCode 문제를 풀 때 떠올리지 못했을까 하며 아쉬웠다. 내 지능이 부족한건지 알고리즘를 배우면서 창의적인 아이디어를 구상하는 연습이 부족했던건지 몰라도, 후자라고 생각하고 계속 연습해보려고 한다&amp;hellip;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Kotlin in Action: What and Why</title>
        <link>https://truealarm.github.io/p/kotlin-in-action-what-and-why/</link>
        <pubDate>Mon, 23 Jan 2023 21:14:32 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/kotlin-in-action-what-and-why/</guid>
        <description>&lt;p&gt;최근 &lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=_Of8e0o6u3U&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kakao tech 유튜브 채널&lt;/a&gt;에서 카카오톡 메시징 시스템을 C++ 서버에서 Kotlin 서버로 재건축한 과정을 설명하는 영상을 봤다. 이미 오랜 기간 운영하던 C++ 서버를 드러내기로 결심한 이유가 가장 궁금했는데,  C++ 서버를 유지보수할 인력이 점점 줄어들고 있고 수년후에는 인력난이 더 심각해져 정상적인 운영이 불가능할 것 같아서 이런 결정을 내렸다고 영상에서 설명한다. 뿐만 아니라 다른 JVM 기반 서버와 호환성과 통신 과정에 대해 고려할 사항이 줄어들고, gc 정책을 변경한 뒤 벤치마크 테스트를 수행한 결과 기존 C++ 서버와 큰 성능 차이가 없었다고 한다.&lt;/p&gt;
&lt;p&gt;사실 영상을 보기 전부터 현업에서 Spring과 함께 활발하게 사용되는 언어라 깊이있게 공부할 필요성을 느꼈고, 개인적으로 Java/Kotlin 기반 서버가 왜 이렇게 인기가 많고, 왜 이곳저곳에서 사용되는지 궁금했다. 잠시 시간을 내서 Kotlin이 어떤 느낌의 언어인지만 살펴봤는데 주력 언어로 배우고 싶을 정도로 매력적인 언어라는 생각이 들었다. 그래서 &lt;a class=&#34;link&#34; href=&#34;https://www.amazon.com/Kotlin-Action-Dmitry-Jemerov/dp/1617293296&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kotlin In Action&lt;/a&gt; 서적을 시작으로 차근차근 공부해보려고 한다. 이번 포스트는 1,2 Chapter에 대한 내용을 다룬다.&lt;/p&gt;
&lt;h2 id=&#34;the-philosophy-of-kotlin&#34;&gt;The philosophy of Kotlin&lt;/h2&gt;
&lt;p&gt;Kotlin은 IntelliJ의 개발사인 JetBrains에서 만든 언어이며, JetBrains의 IDE 사용 데이터와 커뮤니티의 피드백을 반영하며 수년간 많은 변화를 겪다 출시되었다. 개발자들은 실용적(Pramatic)이고, 간결(Concise)하고, 안전(Safe)하면서 기존 Java와 상호 운용 가능(Interoperable)한 언어인 Kotlin을 탄생시켰다. 물론 자세히 배우지 않고는 이 4가지 특성이 어떻게 반영되고 있는지 모르겠지만, 몇가지 주요 특성만 살펴봐도 Koltin의 철학에 대해 공감할 수 있을 것이다. 개인적으로 Kotlin이 맘에 들었던 이유는 &lt;u&gt;&lt;strong&gt;Kotlin의 철학과 4가지 특성 모두 실제 현업에서 발생하는 비즈니스 문제 해결을 중시한다는 점이다.&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;그래서 Kotlin은 최첨단 컴파일러 기술을 통해 혁신적인 성능과 발전을 도모하기 보다, 이미 다른 언어에서 수년간 사용되며 좋다고 검증된 기술들을 모아 Kotlin 스타일로 녹이는 것에 집중한다. 아마 여러 언어를 배워본 사람이라면, 이후에 나오는 Kotlin 기능은 이미 다른 언어의 주력 기능임을 알아차릴 수 있을 것이다. (그래서 금방 배울 수 있다!)&lt;/p&gt;
&lt;p&gt;Kotlin은 직관적이고 가독성이 높은 코드를 작성하도록 설계되어 있고, Java와 달리 형식적으로 반복되는 코드가 필요없어 아주 간결한 코드를 짤 수 있는게 특징이다. 간결한 코드는 그만큼 우리가 읽어야 하는 코드의 양을 줄여주고, 가독성이 높은 코드는 기존 코드를 더욱 빨리빨리 읽을 수 있게 도와준다. 이는 개발자가 최대한 비즈니스 문제 해결에만 신경쓰면 된다는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;안전하다는 특성도 Kotlin의 장점을 부각시켜 주는 특성이다. Kotlin은 정적 타입 언어로 컴파일 타임에 모든 표현식의 타입이 결정된다. 그래서 컴파일 타임에서 타입 검사를 통해 최대한 많은 버그를 미리 잡아낼 수 있다. 물론 모든 변수나 표현식에 대해 자료형을 명시하지 않아도 컴파일러가 추론 가능한 경우는 자동으로 타입을 부여해주므로 개발자의 부담이 크게 늘어나지 않는다. 오히려 사소한 버그를 미연에 방지하여 불필요한 디버깅 시간을 줄일 수 있어 훨씬 이득이다. 또한 컴파일 타임에 모든 변수의 타입을 알 수 있기에 런타임 타입 검사를 제거하여 성능 향상을 노릴 수 있고, IDE에 타입 정보를 제공하여 더욱 스마트한 자동 완성 기능 등에 활용할 수 있다.&lt;/p&gt;
&lt;p&gt;안전성 관련해서 Kotlin은 null을 기본적으로 허용하지 않는 언어이기도 하다. 방심에서 비롯되는 수많은 널 포인터 참조 이슈와 같은 문제를 개발자가 방심하지 못하도록 막아주는 동시에, 깔끔하게 null을 처리할 수 있는 연산자나 구문을 제공하여 간결함을 침해하지 않는다.&lt;/p&gt;
&lt;p&gt;마지막으로 Kotlin은 기존 Java 코드와 완벽히 호환될 수 있어, Java 라이브러리를 그대로 사용할 수 있고, Java에서도 Kotlin 라이브러리를 사용할 수 있다. 그래서 Java가 사용되고 있는 모든 환경에서 Kotlin도 사용할 수 있다. 심지어 Java 파일과 Kotlin 파일을 같은 프로젝트에 포함시켜 개발할 수 있다. 이는 Java가 갖는 강력한 장점을 Kotlin도 누릴 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;h2 id=&#34;kotlin-basics&#34;&gt;Kotlin basics&lt;/h2&gt;
&lt;p&gt;Chapter 2는 Kotlin 언어의 핵심 기능과 기본적인 문법을 설명한다. 여기서 내가 따로 정리한 내용은 기본적인 문법에 대한 내용은 빼고, 내가 생각하기에 한번 더 언급할 만한 내용만 다뤘으니 자세한 내용은 서적을 참고하면 된다.&lt;/p&gt;
&lt;h3 id=&#34;statements-and-expressions&#34;&gt;Statements and Expressions&lt;/h3&gt;
&lt;p&gt;statement는 컴파일러가 이해할 수 있는 독립적인 코드 구문, 실행 과정에서 유의미한 효과를 발생시키는 구문을 의미하고, expression은 statement 중에서 실행 과정에서 값으로 평가될 수 있는 구문을 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val number = 1 // statement&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func(); // expression&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 예시에서 &lt;code&gt;val number = 1&lt;/code&gt; 문은 컴파일러가 이해할 수 있고 실행 시 변수를 선언하는 효과를 갖지만, 값으로 평가되지 않는 구문이다. 반면에 함수를 호출하는 &lt;code&gt;func()&lt;/code&gt; 구문의 경우는 실행 이후 함수의 반환값으로 값을 갖는 expression에 속한다.&lt;/p&gt;
&lt;p&gt;이 얘기를 꺼낸 이유는 Kotlin에서 반복문을 제외하고 if/else문, switch문, 심지어 try/catch 문 등의 block statement가 expression으로 처리되기 때문이다. 그래서 아래처럼 switch 구문이 값을 갖는 구문으로 평가될 수 있고, 대입문의 피연산자로 사용하는 등의 문법이 가능하다. C, C++, Java 같은 언어였다면 익명 함수(lambda)와 &lt;code&gt;return&lt;/code&gt; 구문을 통해 구현해야 하지만, Kotlin에서는 형식적인 코드가 전부 필요없어 간결하고, 오히려 가독성이 높은 코드로 구현있는 것이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;msg&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;OK&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;OK&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;400&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Bad Request&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;Bad Request&amp;#34; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;404&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Not Found&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;Not Found&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;N/A&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;N/A&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;expression-bodies&#34;&gt;Expression bodies&lt;/h3&gt;
&lt;p&gt;Kotlin은 함수의 body를 expression으로만 구성하는게 가능하다. 아래 예시처럼 대입 연산자을 통해 expression이 평가된 값을 반환한다고 명시해주면 된다. if 문이 값을 가질 수 있는 expression임을 알고 있다면 return 구문을 통해 반환을 명시적으로 표현하지 않아도, 직관적으로 함수가 어떻게 동작하는지 이해할 수 있다. 간결함을 중요시하는 Kotlin과 아주 어울리는 문법이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;
&lt;p&gt;Object-oriented programming 언어라면 객체의 데이터(field)는 객체 안으로 집어넣고, 외부에서 직접 접근을 막는 캡슐화(Encapsulation) 원칙을 거의 무조건 고수한다. 내부 데이터인 field에 접근하거나 변경할 때는, field를 추상화한 property를 외부로 노출하고 이를 통해서만 접근하게 만들어 클래스 내부 정보를 최대한 숨긴다.&lt;/p&gt;
&lt;p&gt;Java에서 Class를 정의할 때는 private한 데이터(field)와 데이터 접근자(getter/setter)를 모두 구현해야 property를 정의할 수 있었다. (물론 Java 뿐만 아니라 많은 언어에서도 이런 방식을 많이 사용한다.) 반면에 Kotlin은 field와 accessor의 구분없이 Class에 선언된 변수는 전부 property로 처리된다. mutable한 property는 &lt;code&gt;var&lt;/code&gt;로 immutable한 property는 &lt;code&gt;val&lt;/code&gt;로 선언하면 된다. i.e. &lt;code&gt;var&lt;/code&gt; = writable, &lt;code&gt;val&lt;/code&gt; = readonly&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;isMarried&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;덕분에 field에 접근하는 getter/setter를 구현할 때 단순히 값을 반환/설정하는 형식적인 코드를 굳이 작성하지 않아도 된다. 당연히 getter/setter에서 값 검사와 같은 추가 로직이 필요한 경우 아래처럼 custom accessor를 사용하면 된다. (&lt;code&gt;get&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 키워드를 사용)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;area&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;enums-and-when&#34;&gt;Enums and &amp;ldquo;when&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;Kotlin에서 열거형(enum)은 단순히 type-safe한 일련의 숫자가 아니라, 클래스처럼 property와 method를 정의할 수 있고 초기화할 수 있는 객체이다. 그저 enum 상수의 열거가 끝나는 지점에 세미콜론만 붙여주면 된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;RED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;BLACK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rgb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;256&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;256&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;객체처럼 사용이 가능한 enum class는 기존 enum 상수보다 좀 더 유연하게 사용할 수 있고, when 구문과 같이 사용될 때 진가가 발휘된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;YELLOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ORANGE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;YELLOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BLUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GREEN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BLUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;VIOLET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INDIGO&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Dirty color&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Java의 switch 문에서 분기 조건 변수는 문자열, 열거형, 리터럴 등의 상수만 사용할 수 있지만, Kotlin의 switch 문인 when 구문은 연산식을 조건 변수로 사용할 수 있다. 위 예시에서 두 개의 색을 섞는 &lt;code&gt;mix&lt;/code&gt; 함수는 case 절마다 &lt;code&gt;setOf&lt;/code&gt; 함수가 실행된 결과와 &lt;code&gt;setOf(c1, c2)&lt;/code&gt;을 비교한다.&lt;/p&gt;
&lt;h3 id=&#34;smart-casts&#34;&gt;Smart casts&lt;/h3&gt;
&lt;p&gt;Kotlin은 컴파일러에게 특정 타입이라고 확정할 수 있는 정보가 제공된다면, 코드에서 굳이 형변환을 하지 않아도 되는 Smart cast를 지원한다. 무슨 기능인지 예제를 통해 살펴보자. &amp;ldquo;(1 + 2) + 3&amp;quot;과 같은 간단한 덧셈 연산식을 평가하는 프로그램을 구현한다고 했을 때, 연산식의 피연산자는 이진 트리의 노드로, 각각의 연산자는 &lt;code&gt;Expr&lt;/code&gt;를 상속한 &lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Sum&lt;/code&gt; 클래스로 정의할 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Expr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이 상황에서 연산식을 평가하는 &lt;code&gt;eval&lt;/code&gt; 함수는 인자로 전달된 Expr 클래스가 &lt;code&gt;Num&lt;/code&gt;인 경우는 숫자를 반환하고, &lt;code&gt;Sum&lt;/code&gt;인 경우는 더한 결과를 재귀 호출로 계산하여 반환하면 된다. ( &lt;code&gt;is&lt;/code&gt; 메소드는 Java에서 변수의 자료형을 반환하는 &lt;code&gt;instanceof&lt;/code&gt;과 같다고 보면 된다.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Unknown expression&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위 함수에서 타입을 비교하는 if문 내부로 진입했다면 &lt;code&gt;e&lt;/code&gt;가 &lt;code&gt;Num&lt;/code&gt; 클래스인 것을 확정할 수 있지만, e가 Base 클래스인 &lt;code&gt;Expr&lt;/code&gt; 클래스로 전달됐기 때문에, &lt;code&gt;Num&lt;/code&gt; 클래스로 변환하고 있다. 만약 컴파일러가 좀 더 똑똑해서 if 문이 의미하는 바를 알아차렸다면, 유도리있게 &lt;code&gt;Num&lt;/code&gt;으로 간주할 수 있을 것이다. 이런 기능을 Smart cast라 부르고 Kotlin에서 지원하는 기능이다. 다만 위 경우처럼 if문을 통해 컴파일러가 명확하게 하나의 변수의 타입으로 추론할 수 있는 경우만 적용된다.&lt;/p&gt;
&lt;p&gt;expression body, when, smart cast을 통해 &lt;code&gt;eval&lt;/code&gt; 함수를 Kotlin 스타일로 바꾸면 아래처럼 훨씬 간결하게 짤 수 있다!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Unknown expression&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;참고로 expression으로 처리되는 if, when, try 구문에서 block을 통해 여러 줄을 구성한 경우, 해당 expression이 평가되는 값은 마지막 라인에 위치한 expression이 평가된 값이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;num: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${e.value}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;여기까지 1,2 Chapter를 읽고 다시 정리하기에 중요하다고 생각한 내용을 다루어봤다. 다음 포스트에선 Chapter 3인 &amp;ldquo;Defining and calling functions&amp;quot;를 읽고 정리할 예정이다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Mathematics For Computer Science: Propositions</title>
        <link>https://truealarm.github.io/p/mathematics-for-computer-science-propositions/</link>
        <pubDate>Sun, 22 Jan 2023 16:56:40 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/mathematics-for-computer-science-propositions/</guid>
        <description>&lt;p&gt;컴퓨터 사이언스를 공부할 때, 특히 알고리즘을 배울 때 수학이 나오면 학습 속도가 급격히 더져지고 결국 발목을 잡히곤 한다. 알고리즘의 타당성이나 시간복잡도를 증명 없이 넘어가면, 핵심을 이해하지 못하고 암기하고 있다는 느낌이 들었고, 위태로운 다리에 지식을 쌓고 있다는 생각이 들곤 했다. 수학을 어디서부터 다시 배워야 할 지 몰라 망설이고 있을 때, MIT 대학의 수업인 &amp;ldquo;Mathematics For Computer Science&amp;quot;를 발견했다. 이 수업을 시작으로 차근차근 수학적 지식을 쌓아보려고 한다. 참고로 &lt;a class=&#34;link&#34; href=&#34;https://ocw.mit.edu/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OpenCourseWare&lt;/a&gt;에 &lt;a class=&#34;link&#34; href=&#34;https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/pages/syllabus/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;6.042J&lt;/a&gt;로 등록된 수업으로 온라인 강의와 거의 교재 수준으로 작성된 강의 노트를 누구나 열람할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;명제-proposition&#34;&gt;명제 (Proposition)&lt;/h2&gt;
&lt;p&gt;명제(Proposition)는 참(true) 혹은 거짓(false)이 될 수 있는 서술문(statement)를 의미한다. 예를 들어 &lt;code&gt;1+1 = 2&lt;/code&gt;  식이나 &lt;code&gt;모든 사람은 생각한다&lt;/code&gt; 라는 문장이 proposition이라고 말할 수 있다. 반면에 참, 거짓으로 이어지지 않는 &lt;code&gt;사람은 왜 죽을까?&lt;/code&gt;라는 문장은 proposition에 속하지 않는다.&lt;/p&gt;
&lt;h3 id=&#34;ambiguity&#34;&gt;Ambiguity&lt;/h3&gt;
&lt;p&gt;우리가 일상 생활에서 쓰는 문장과 말은 논리적으로 참, 거짓을 따지기 모호한 경우가 많다. &lt;code&gt;한국인은 대부분 오른손잡이다&lt;/code&gt; 라는 문장에서 &amp;ldquo;대부분&amp;quot;이라는 말은 정확히 전체 한국인 중 얼마의 비율을 의미할까? 그리고 오른손잡이는 오른손은 &amp;ldquo;주로&amp;rdquo; 사용하는 사람이라는 뜻인데, 하루에 오른손 사용 빈도가 50%가 넘으면 오른손 잡이라고 하면 될까? 사실 일반적인 대화에서는 대화의 문맥이나 사회적인 통념 등에 의해 구구절절 정확한 표현을 따지지 않아도 충분히 의사소통이 가능하다.&lt;/p&gt;
&lt;p&gt;하지만 수학에서 모호함은 허용되지 않는다. 개인에 견해에 따라 해석이 달라질 수 있는 단어와 표현을 배제하고 논리정연하게 서술된 문장만이 참과 거짓을 논할 수 있는 것이다. 문장의 의미가 정확히 정의되지도 않았는데 참과 거짓을 논한다는 것 자체가 모순이다. 그래서 수학자들은 일상 생활에서 사용하는 &amp;ldquo;모든&amp;rdquo;, &amp;ldquo;일부&amp;rdquo;, &amp;ldquo;또는&amp;rdquo;, &amp;ldquo;그리고&amp;rdquo; 등의 모호한 단어를 전부 명확히 정의하고 기호로 표시하여 대화한다.&lt;/p&gt;
&lt;h2 id=&#34;imply&#34;&gt;Imply&lt;/h2&gt;
&lt;p&gt;P이면 Q이다, if P then Q 처럼 두 개의 proposition을 가정과 결론의 논리적인 관계로 나타날 때 imply를 사용하고 P-&amp;gt;Q로 표현한다. imply는 proposition이나 일상 용법에도 흔히 나타나는 용법이지만, 직관적이지 않은 부분이 있어 따로 얘기할 만한 내용이 있다. 우선 imply의 진리표는 다음과 같다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;P&lt;/th&gt;
&lt;th&gt;Q&lt;/th&gt;
&lt;th&gt;P implies Q&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;ldquo;리만 가설이 참이라면, 모든 실수 x에 대해 x&lt;sup&gt;2&lt;/sup&gt;는 0보다 크다.&amp;rdquo; 라는 문장은 &amp;ldquo;리만 가설이 참이라면&amp;quot;가 가정 P, &amp;ldquo;모든 실수에 대해 x&lt;sup&gt;2&lt;/sup&gt;는 0보다 크다&amp;quot;라는 결론 Q가 P implies Q 형태를 이루는 proposition이다. 리만 가설은 아직까지 참/거짓이 증명되지 않은 유명한 밀레니엄 문제라 참/거짓을 알 수 없지만, &amp;ldquo;모든 실수에 대해 x&lt;sup&gt;2&lt;/sup&gt;는 0보다 크다&amp;quot;라는 proposition은 이미 참으로 증명된 사실이다. 진리표에 따르면 가정 P의 참/거짓 유무에 상관없이 결론 Q가 참이면 결국 참이므로 해당 proposition은 참이다.&lt;/p&gt;
&lt;p&gt;결론 Q가 참인 경우에는 결국 결론이 맞는 말이니 proposition 자체가 맞다고 직관적으로 생각할 수 있지만, 가정 P와 결론 Q 모두 거짓인 proposition도 참인 것은 직관적이지 않다. 어느 한 드라마에서 여주가 남주에게 &amp;ldquo;네가 외계인이면 난 뱀파이어다&amp;rdquo; 라고 말하는 장면이 나온다. 이 문장을 proposition으로 본다면, 가정과 결론 모두 거짓이라 참인 proposition이 된다. (물론 드라마에선 남주가 외계인이라는 가정이 참이였다..) 일생 생활에서 우리는 &amp;ldquo;너가 뱀파이어일 리가 없다&amp;quot;라는 부정의 의미로 반어법을 사용해서 더욱 직관적이지 않아 보이는 것 같다.&lt;/p&gt;
&lt;p&gt;논리적으로 따져보면 가정 명제부터 거짓이라면 결론 명제에 대한 참/거짓을 판단할 수 없다. 하지만 proposition에서 참 혹은 거짓 이외의 &amp;ldquo;모름&amp;rdquo;, &amp;ldquo;알 수 없음&amp;rdquo; 등의 답은 존재하지 않는다. 때문에 수학자들은 가정이 거짓이라면 결론과 상관없이 참으로 결론을 지었다. 여기서 나는 거짓으로 결론 짓는게 더 직관적인데 왜 참으로 정한건 지 이해가 가지 않았는데, 한 블로그 &lt;a class=&#34;link&#34; href=&#34;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=kyj0833&amp;amp;logNo=220990303979&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;포스트&lt;/a&gt;를 보고 이해가 갔다. &amp;ldquo;P이면 P이다&amp;rdquo; 라는 명제는 직관적으로 참으로 여겨진다. 근데 수학자들이 가정 P가 거짓인 경우 거짓 명제인 거로 정했다면 &amp;ldquo;P이면 P이다&amp;rdquo; 라는 명제를 거짓으로 봐야하는 모순적인 상황이 발생한다. 일상 생활에서 직관적이지 않을 수 있지만, 수학에서는 오히려 직관적으로 보이는 선택이였던 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결국 implication은 결론 Q가 참이거나 가정 P가 거짓인 경우 참이 되는 proposition이라고 정의할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;iff&#34;&gt;IFF&lt;/h2&gt;
&lt;p&gt;P if and only if Q 라는 proposition는 P와 Q가 논리적으로 동일한 관계를 나타낸다. 그래서 NXOR 과 진리표가 동일하고 P &amp;lt;-&amp;gt; Q로 표현한다. P-&amp;gt;Q 에서 Q는 P이기 위한 필요 조건(necessary condition)이고 P는 Q이기 위한 충분 조건(sufficient condition)이다. 서로가 서로에게 필요 조건인 동시에 충분 조건이므로 IFF 관계를 필요충분조건(necessary and sufficient condition)이라고도 부른다.&lt;/p&gt;
&lt;h2 id=&#34;predicates-and-quantifiers&#34;&gt;Predicates and Quantifiers&lt;/h2&gt;
&lt;p&gt;지금까지 예제로 나온 proposition는 모든 경우에 수에 대해 일일히 셀 수 있을 정도의 참/거짓을 판단하기 쉬웠지만, 가능한 모든 경우를 전부 확인하기 어려운 proposition도 많다. 예를 들어 &amp;ldquo;모든 음수가 아닌 숫자 n에 대해 p(n) = n&lt;sup&gt;2&lt;/sup&gt; + n + 41은 소수이다.&amp;rdquo; 라는 proposition에서 n&amp;lt;=39인 경우만 참이고 그 이후는 거짓이 된다. cf. &lt;code&gt;p(40) = 40*40 + 40 + 41 = 41&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;모든 ~에 대해(for all) 라는 표현은 기호로 All에서 A를 뒤집어 ∀ 기호로 표현한다. 그래서 위 proposition을 &lt;code&gt;∀n ∈ N. p(n) is prime&lt;/code&gt; 으로 깔끔하게 표현할 수 있다. 다른 예시로 &amp;ldquo;모든 양의 정수 a, b, c, d에 대해 a&lt;sup&gt;4&lt;/sup&gt; + b&lt;sup&gt;4&lt;/sup&gt; + c&lt;sup&gt;4&lt;/sup&gt;= d&lt;sup&gt;4&lt;/sup&gt;을 만족하는 해가 없다&amp;rdquo; 라는 proposition은 &amp;ldquo;∀a,b,c,d ∈ Z&lt;sup&gt;+&lt;/sup&gt;. a&lt;sup&gt;4&lt;/sup&gt; + b&lt;sup&gt;4&lt;/sup&gt; + c&lt;sup&gt;4&lt;/sup&gt;≠ d&lt;sup&gt;4&lt;/sup&gt;&amp;ldquo;라고 표현할 수 있다. 그리고 이 방정식에 대한 해는 1987년 Noam Elkies에 의해 발견되어 거짓인 proposition으로 판명났지만 218년이나 걸렸다.&lt;/p&gt;
&lt;p&gt;이와 비슷하게 무작위 값을 대입해서 확인하는 방식으로 대부분 경우에서 참인 결과가 나와도 우리가 예상치 못한 값으로 거짓으로 판명될 수 있다. 충분히 많은 경우의 수를 대입해서 모두 참이 나와도 결국 모든 경우의 수를 전부 확인하지 않는 이상 확신할 수 없다. 대부분 컴퓨터의 빠른 연산 능력을 통해 유한한 경우의 수를 시도해보지만, 결국 현대 기술로도 모든 경우의 수를 확인할 수는 없다. 그래서 증명은 수학의 꽃이라고 불릴 정도로 난해하고 신기한 영역이지 않을까 싶다.&lt;/p&gt;
&lt;h3 id=&#34;predicates&#34;&gt;Predicates&lt;/h3&gt;
&lt;p&gt;하나 이상의 변수에 의해 참/거짓이 결정되는 proposition을 predicate라고 부른다. 위 예시에서 봤던 &amp;ldquo;p(n) = n&lt;sup&gt;2&lt;/sup&gt; + n + 41은 소수이다.&amp;ldquo;가 predicate에 속하는 것이다.&lt;/p&gt;
&lt;h3 id=&#34;quantifier&#34;&gt;Quantifier&lt;/h3&gt;
&lt;p&gt;변수에 따라 참/거짓 여부가 달라지는 predicate는 모든 경우에 대해 참일 수도 있고, 몇몇 경우에 대해서만 참일 수 있다. 이렇게 predicate가 참이 되는 빈도수를 모호함 없이 수학적으로 정확히 표현할 때 사용하는게 quantifier이다. 모든 경우에 대해 항상 참이 될 때 사용하는 quantifier를 Universal quantification라고 부르며 ∀ 기호로 표현한다. 몇몇 경우에 대해서만 참이 될 때 사용하는 quantifier는 Existential quantification라고 부르며 ∃ 기호로 표현한다. Existential quantification는 보통 참인 경우가 존재한다(there exists)라고 읽으므로 E를 뒤집은 기호를 사용한다.&lt;/p&gt;
&lt;p&gt;predicate에서 quantifier가 여러 개일 수도 있다. 예를 들어 &amp;ldquo;2보다 큰 모든 짝수는 두 소수의 합이다.&amp;rdquo; 라는 predicate를 좀 더 명확한 표현으로 바꾸면 &amp;ldquo;모든 2보다 큰 짝수 n에 대해 n = p+q를 만족하는 소수 p, q가 존재한다.&amp;ldquo;가 된다. 기호를 이용하면 더욱 간결하게 표현할 수 있다. &lt;code&gt;∀n ∈ Evens. ∃p,q ∈ Primes. n = p+q&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;order-of-quantifiers&#34;&gt;Order of quantifiers&lt;/h3&gt;
&lt;p&gt;quantifier가 여러 개인 predicate는 순서에 따라 의미가 완전히 달라진다. 위에서 사용한 predicate의 quantifier 순서를 바꾸면  ∃p,q ∈ Primes. ∀n ∈ Evens. n = p+q 가 된다. 이를 해석하면 &amp;ldquo;소수인 p, q가 존재한다. 모든 짝수인 n에 대해 n=p+q가 항상 참이 되는.&amp;rdquo; 어순만 반대로고 달라진게 없어보이지만, 이 문장이 의미하는 바는 소수인 p와 q의 합으로 모든 짝수를 만들 수 있는 마법의 p,q가 존재한다는 뜻이 된다.&lt;/p&gt;
&lt;h3 id=&#34;negating-quantifiers&#34;&gt;Negating Quantifiers&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;모든 사람이 피자를 좋아하는 것은 아니다.&amp;rdquo; 라는 문장과 &amp;ldquo;피자를 좋아하지 않는 사람도 있다.&amp;rdquo; 문장이 뜻하는 바는 같다. 기호로 표현하면 각각 &lt;code&gt;NOT(∀x. P(x))&lt;/code&gt;와 &lt;code&gt;∃x. NOT(P(X))&lt;/code&gt;으로 표현할 수 있고, 두 개의 식이 같다는 사실을 통해 quantifier에 부정 연산이 적용되면 ∀ -&amp;gt; ∃ 또는 반대로 바뀌는 것을 알 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;validity-and-satisfiability&#34;&gt;Validity and Satisfiability&lt;/h2&gt;
&lt;p&gt;여러 명제로 이루어진 논리식(Propositional formula)에서 모든 명제의 참/거짓 여부와 상관없이 항상 참이 될 때 타당(valid)한 명제라고 부른다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[P AND (Q OR R)] IFF [(P AND Q) OR (P AND R)]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 명제에서 P, Q, R에 대해 모든 경우의 수를 따져 진리표를 작성해보면 결국 &lt;code&gt;P AND (Q OR R)&lt;/code&gt;과 &lt;code&gt;(P AND  Q) OR (P AND R)&lt;/code&gt; 은 같은 식인 것을 알 수 있다. 이처럼 모든 경우에 수에 대해 참으로 판별된 명제는 타당하다고 말할 수 있다. 비슷하게 주어진 명제를 참으로 만드는 경우의 수가 하나라도 존재하는 경우가 존재하면 satisfiable하다고 말한다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Today I Learnd: 캡슐화(Encapsulation)</title>
        <link>https://truealarm.github.io/p/today-i-learnd-%EC%BA%A1%EC%8A%90%ED%99%94encapsulation/</link>
        <pubDate>Fri, 20 Jan 2023 14:36:42 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/today-i-learnd-%EC%BA%A1%EC%8A%90%ED%99%94encapsulation/</guid>
        <description>&lt;p&gt;기본적인 개념에 대한 글을 머리속으로 슥슥 읽으면 이해했다는 느낌을 받아도 막상 누군가에게 설명하려고 하면 쉽지 않다. 조리 있게 말하는 언어적 능력이나 논리정연하게 서술하는 것에 익숙하지 않아 그럴 수도 있지만, 완벽히 이해하지 못했을 가능성이 크다. 사실 어느 쪽이 문제인지 상관없이 다른 사람에게 어려운 개념을 이해하기 쉽게 설명할 수 있는 능력은 개발자에게 정말 중요하다고 생각한다. 가벼운 내용이라도 하루에 최소 한번 씩 오늘 읽은 글을 정리하고, 내 언어로 좀 더 쉽게 재가공해보려고 한다. 이번에는 Object-oriented programming 언어의 핵심 개념인 캡슐화(Encapsulation)를 다룬다.&lt;/p&gt;
&lt;h2 id=&#34;meaning&#34;&gt;Meaning&lt;/h2&gt;
&lt;p&gt;객체 지향 프로그래밍(Object-oriented programming) 언어에서 Encapsulation은 크게 2가지 의미를 내포한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터와 데이터를 조작하는 메소드를 하나의 객체로 전부 묶는 행위 (bundling)&lt;/li&gt;
&lt;li&gt;객체의 내부 요소(data or method)에 직접 접근하지 못하도록 막는 행위 (information hiding)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;첫 번째 의미인 bundling은 객체와 관련된 데이터(state)와 method는 전부 하나의 객체로 묶어서 객체 간 독립성과 응집도를 높이는 방법이다. 독립성과 응집도가 높아지면 요구 사항 변경으로 인한 코드 변경 시에도 최소한의 코드만 수정하면 된다. 예시로 Class에서 멤버 변수와 멤버 함수를 정의하는게 bundling이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;두 번째 의미인 information hiding은 객체의 내부 데이터와 method는 객체 내부에서만 접근 가능하고, 외부에서는 공개된 interface를 통해서 접근을 허용하는 방법을 말한다. 그래서 데이터에 접근하거나 변경할 때 객체의 내부 구현체를 살펴보지 않아도 되고, 공개된 interface 정보만 살펴보면 된다. 또한 interface를 통해 제공하는 getter, setter로 데이터에 접근하면 의도치 않은 값으로 변경되는 것을 막을 수 있는 Defensive 프로그래밍이 가능하며 이는 프로그램의 견고함(robustness)을 높여준다. 예시로 Java, C++에서는 접근 제어 지시자인 private, public으로, 파이썬은 name mangling으로 내부 데이터로 직접 접근을 막는다. 그리고 외부로 공개하는 interface나 헤더 파일로 내부 구현체에 대한 정보를 은닉한다.&lt;/p&gt;
&lt;h2 id=&#34;side-notes&#34;&gt;Side notes&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Information hiding은 Encapsulation이 아니다&lt;/a&gt; 라고 주장하는 전문가도 있고, bundling과 information hiding 모두 Encapsulation에 포함되는 개념이라고 보는 전문가도 있다. 나는 두 개념 모두 내포하고 있는 개념이라고 본다..&lt;/li&gt;
&lt;li&gt;OOP 언어로 고안된 언어가 아닌 C 언어에서도 &lt;code&gt;extern&lt;/code&gt; 키워드를 사용하고 헤더 파일을 분리하는 방식으로 Encapsulation이 가능하다. 이처럼 Encapsulation은 OOP에만 국한된 개념은 절대 아니다.&lt;/li&gt;
&lt;li&gt;Encapsulation과 마찬가지로 OOP의 대표적인 특성 중 하나인 상속(Inheritance)은 종종 Encapsulation을 해칠 수 있다. 특히 has-a 관계에서 상속을 사용하면 부모의 모든 데이터와 메소드를 물려받기 때문에 자식은 필요없는 정보까지 신경써야 되고, 이는 난잡한 bundling으로 귀결되곤 한다. 관련해서는 Inheritance에 대해 공부하면서 한번 더 정리할 예정이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cl.cam.ac.uk/teaching/0910/OOProg/lectures_annotated.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cl.cam.ac.uk/teaching/0910/OOProg/lectures_annotated.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Guaranteed copy elision. What&#39;s difference?</title>
        <link>https://truealarm.github.io/p/guaranteed-copy-elision.-whats-difference/</link>
        <pubDate>Sat, 31 Dec 2022 19:46:30 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/guaranteed-copy-elision.-whats-difference/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Copy_elision&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Copy elision&lt;/a&gt;은 불필요한 객체의 복사 과정을 제거하는 컴파일러 최적화 기법이다. C++ 컴파일러에도 Copy elision 기법이 적용되어 있었고, 컴파일러가 생략이 가능한 경우를 판단하여 비효율적인 코드를 알아서 최적화 해주었다. 그러다 C++17부터 Guaranteed copy elision이라는 &lt;a class=&#34;link&#34; href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;제안&lt;/a&gt;이 받아들여지면서 Copy elision 기법에 변화가 생겼다. 이름만 보면 한층 더 강력한 최적화 기법을 적용한 것 같지만, 임시 객체(temporary)와 prvalue에 대한 명세를 살짝 바꿨을 뿐 어떠한 최적화 기법이 추가되지는 않았다. 어떤 변화와 있었고 뭐가 더 좋아진건지 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;copy-elision&#34;&gt;Copy elision&lt;/h2&gt;
&lt;p&gt;Copy elision이 어떤 최적화 기법인지는 위키피디아에 잘 나와있지만, 기본적인 내용부터 확실히 알고 넘어가자.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;explicit&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// the copy constructor has a observable side effect
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;                      &lt;span class=&#34;c1&#34;&gt;// it modifies an object with static storage duration
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// direct-initialization, calls C::C(int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// direct-list-initialization, calls C::C(int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// copy-initialization, calls C::C(const C&amp;amp;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// copy-initialization, calls C::C(const C&amp;amp;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// prints 0 if the copy was elided, 2 otherwise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;c1&lt;/code&gt;는 생성자에 직접 인자를 전달해 초기화하는 direct-initialization, &lt;code&gt;c2&lt;/code&gt;는 중괄호(brace)를 사용해 객체를 초기화한 direct-list-initialization라고 부르며 c++11부터 추가된 기능이다. (c++11 이전은 괄호와 동일하게 처리됨) &lt;code&gt;c3&lt;/code&gt;, &lt;code&gt;c4&lt;/code&gt;는 각각 direct-initialization, direct-list-initialization으로 초기화한 임시 객체를 복사해 초기화하는 copy-initialization이다.&lt;/p&gt;
&lt;p&gt;copy-initialization로 초기화하는 과정은 생성한 임시 객체를 그대로 사용하지 않고, 복사/이동 생성자를 통해 임시 객체를 복사/이동하므로 direct-initialization보다 더 많은 연산이 요구된다.&lt;/p&gt;
&lt;p&gt;임시 객체는 어차피 초기화할 때만 사용되므로, 불필요한 복사/이동 생성자를 생략하고 객체를 직접 초기화하는 것처럼 처리하는게 Copy elision이다. 하지만 예제의 구조체처럼 복사 생성자가 observable한 side effect(&lt;code&gt;n&lt;/code&gt;을 변경하는 코드)가 있는 경우, 컴파일러 정책에 따라 적용 유무가 달라질 수 있다. c++17의 경우 Mandatory elision of copy/move operations라고 해서 side effect가 있더라도 prvaule로 초기화하는 식에는 무조건 Copy elision을 적용한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Mandatory elision of copy/move operations&lt;/strong&gt; (since c++17)&lt;/p&gt;
&lt;p&gt;Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. The copy/move constructors need not be present or accessible:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the initialization of an object, when the initializer expression is a &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/value_category&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/cv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cv-qualification&lt;/a&gt;) as the variable type:&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;return-value-optimization&#34;&gt;Return Value Optimization&lt;/h3&gt;
&lt;p&gt;함수에서 생성한 임시 객체를 값으로 반환할 때, 임시 객체의 scope는 함수 내부이므로 반환 이후 소멸된다. 소멸되기 전에 반환할 객체를 생성하고 임시 객체를 복사하는 과정이 필요하다. 하지만 임시 객체는 다른 객체를 초기화하는 용도로만 사용되므로, 복사 과정을 생략하고 그대로 임시 객체를 반환하는 최적화 기법을 Return Value Optimization(RVO)라고 부르며 Copy elision의 한 종류이다.&lt;/p&gt;
&lt;p&gt;반환식에 바로 객체의 초기화식이 와서 임시 객체의 이름이 없는 경우 Unnamed RVO (URVO), 임시 객체를 생성하는 식과 반환식이 분리되어 이름이 있는 경우 Named RVO (NRVO)라고 분류된다. NRVO의 경우 두 개의 식 사이에 다른 대입 연산이 올 수 있는게 특징이고, c++17 이후에도 Non-mandatory한 copy elision으로 간주되어 컴파일러 정책에 따라 적용 유무가 달라진다. (URVO는 c++17부터 필수적으로 적용)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;A copy was made.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// copy-initialization, calls C::C(const C&amp;amp;) 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// copy-initialization, calls C::C(const C&amp;amp;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위의 예제코드의 &lt;code&gt;f&lt;/code&gt; 함수가 전형적인 URVO를 적용할 수 있는 케이스이다. 이후 반환된 객체를 초기화할 때 역시 copy-initialization이 필요하지만, Copy elision 기법에 의해 생략될 수 있다. 따라서 &amp;ldquo;Hello world&amp;rdquo; 문자열이 최대 2번, 최소 0번 출력될 수 있고, c++17 이후라면 출력되지 않을 것이다.&lt;/p&gt;
&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;
&lt;p&gt;c++17 이전 Copy elision 최적화 기법에 관해 컴파일러가 필수적으로 보장해야 할 명세가 없었고, 어차피 생략되는 복사/이동 생성자의 유무를 신경쓰지 않았기에 예상치 못한 &lt;a class=&#34;link&#34; href=&#34;https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/LEzTGnc4FZo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;문제&lt;/a&gt;가 발견된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NonMoveable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;NonMoveable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;NonMoveable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NonMoveable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;NonMoveable&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;RVO를 지원하는 c++11 컴파일러에서 위 예제 코드를 컴파일하면 에러가 발생한다. 이동 생성자가 지워진 &lt;code&gt;NonMoveable&lt;/code&gt; 구조체가 임시 객체로 생성되고, 반환되면서 이동을 시도하기 때문이다. 실제로 RVO가 적용되어 복사/이동 생성자가 사용되지 않지만, 형식적인 생성자가 없다는 이유로 컴파일을 거부하는 상황이 발생하는 것이다. 이는 c++11으로는 non-moveable 타입에 대한 factory 함수를 만들 수 없음을 의미한다.&lt;/p&gt;
&lt;p&gt;게다가, non-moveable 타입은 AAA(Always Almost Auto) 스타일로 &lt;a class=&#34;link&#34; href=&#34;https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#:~:text=and%20most%20readable%3F-,6.%20Are%20there%20any%20cases%20where%20it%20is%20not%20possible%20to%20use%20the%20style%20in%20%234%20to%20declare%20all%20local%20variables%3F,-There%20is%20one&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;초기화할 수 없게 된다&lt;/a&gt;. (e.g. amotic, lock_guard)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NonMoveable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이런 제한 사항은 프로그래머에게 동적 할당된 주소를 반환하는 패턴을 사용하거나, 단순히 에러가 발생하지 않게 하기 위해 흑마법을 사용할 수 밖에 만든다. 좋은 언어라면 프로그래머가 나쁜 코드를 작성하지 않고, 자연스럽게 좋은 코드를 짤 수 있도록 설계되어 있다. 다행히 c++17에서는 이런 문제가 해결됐다. (Richard Smith가 제안한 Guaranteed copy elision라는 &lt;a class=&#34;link&#34; href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;제안&lt;/a&gt;을 통해 문제를 해결함)&lt;/p&gt;
&lt;h2 id=&#34;guaranteed-copy-elision&#34;&gt;Guaranteed copy elision&lt;/h2&gt;
&lt;p&gt;Guaranteed copy elision은 기존 c++이 prvalue와 glvalue를 어떻게 정의하고 있었고, pvalue가 표현식으로 평가될 때 어떤 일이 벌어지고 있었는 지에 집중한다. 아래는 c++17 이전에 정의하고 있던 value categories에 대한 설명이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;em&gt;lvalue&lt;/em&gt; (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [ Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. - end example ]&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;xvalue&lt;/em&gt; (an &amp;ldquo;eXpiring&amp;rdquo; value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). Certain kinds of expressions involving rvalue references (8.3.2) yield xvalues. [ Example: The result of calling a function whose return type is an rvalue reference to an object type is an xvalue (5.2.2). - end example ]&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;glvalue&lt;/em&gt; (&amp;ldquo;generalized&amp;rdquo; lvalue) is an lvalue or an xvalue.&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;rvalue&lt;/em&gt; (so called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;prvalue&lt;/em&gt; (&amp;ldquo;pure&amp;rdquo; rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue. - end example ]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 설명만 보면 &lt;code&gt;NonMoveable{}&lt;/code&gt; 처럼 임시 객체를 초기화하는 식은 prvalue로 분류하고, &lt;code&gt;NonMoveable{}.x&lt;/code&gt;은 왜 glvalue로 분류할 수 있었는 지 알기 어렵다.&lt;/p&gt;
&lt;p&gt;Richard Smith는 prvalue와 glvaule 간 혼란을 줄이기 위해 prvalue는 객체를 초기화하는 식, glvalue는 identity를 부여하는 식으로 의미를 구체화했다. 그래서 객체를 초기화하는 식(&lt;code&gt;NonMoveable{}&lt;/code&gt;)은 identity를 갖지 않으므로 prvalue로 분류할 수 있고, identity가 부여되는 식(&lt;code&gt;NonMoveable{}.x&lt;/code&gt;)은 glvalue로 구분할 수 있다. 이로 인해 c++17 부터는 &lt;a class=&#34;link&#34; href=&#34;https://timsong-cpp.github.io/cppwp/n4659/basic.lval&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;value categories에 대한 정의&lt;/a&gt;가 바뀌었지만, 기존 값 분류와 어긋나지는 않는다. (조금 더 자세한 기준이 생긴 것으로 봄)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A glvalue [(generalized lvalue)] is an expression whose evaluation determines the identity of an object, bit-field, or function.&lt;/li&gt;
&lt;li&gt;A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of an operand of an operator, as specified by the context in which it appears.&lt;/li&gt;
&lt;li&gt;An xvalue is a glvalue that denotes an object or bit-field whose resources can be reused (usually because it is near the end of its lifetime).&lt;/li&gt;
&lt;li&gt;An lvalue is a glvalue that is not an xvalue.&lt;/li&gt;
&lt;li&gt;An rvalue is a prvalue or an xvalue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;추가적으로 prvalue에 identity가 부여되어 glvalue로 타입 변경이 일어나는 행위를 Temporary materialization이라고 정의하며, c++17 표준에 명시되어 있다. 이 정의가 중요한 이유는 임시 객체가 실제로 필요하기 전까진, 다시 말해 identity가 부여되어 materialization되기 전까지 임시 객체를 생성하지 않아도 되기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Temporary materialization&lt;/strong&gt; (since c++17)&lt;/p&gt;
&lt;p&gt;A &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/value_category#prvalue&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;prvalue&lt;/a&gt; of any complete type &lt;code&gt;T&lt;/code&gt; can be converted to an xvalue of the same type &lt;code&gt;T&lt;/code&gt;. This conversion initializes a &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/lifetime#Temporary_object_lifetime&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;temporary object&lt;/a&gt; of type T from the prvalue by evaluating the prvalue with the temporary object as its result object, and produces an xvalue denoting the temporary object. If &lt;code&gt;T&lt;/code&gt; is a class or array of class type, it must have an accessible and non-deleted destructor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체의 생명주기를 명시하고있는 &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/lifetime&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lifetime&lt;/a&gt; 문서에도 c++17에서 임시 객체는 prvalue가 나타나는 식에서 생성되는게 아니라, materialized될 때 생성한다고 나와있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Temporary objects are created when a prvalue is &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/implicit_conversion#Temporary_materialization&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;materialized&lt;/a&gt; so that it can be used as a glvalue, which occurs (since C++17) in the following situations:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그래서 c++17 이전 관점으로 아래 코드를 본다면, &amp;ldquo;임시 객체를 생성하고 임시 객체를 x로 이동하지만 Copy elision으로 이동 과정을 생략함&amp;quot;으로 해석하고, c++17 이후 관점으로는 &amp;ldquo;x를 초기화하는 식&amp;quot;으로 해석할 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;임시 객체가 생성되지 않는다면 복사나 이동을 생각할 필요 자체가 없어진다. 결국 Copy elision과 복사/이동 생성자 사이의 의존성이 모두 사라져, 이전에 발생했던 모순과 같은 문제들이 전부 해결된다.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Guaranteed copy elision는 copy elision를 보완하는 내용이 아닌, 애매하던 기존 c++ value categories의 정의를 좀 더 구체화하고, 임시 객체가 실제 필요할 때 생성하는 방식으로, c++의 기능을 개선함과 동시에 문제를 해결하였다. 이를 통해 c++17에서 임시 객체를 어떻게 바라볼 지, value categories가 갖는 의미에 대해 자세히 알 수 있었다.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://devblogs.microsoft.com/cppblog/guaranteed-copy-elision-does-not-elide-copies/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://devblogs.microsoft.com/cppblog/guaranteed-copy-elision-does-not-elide-copies/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/cpp/language/copy_elision&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.cppreference.com/w/cpp/language/copy_elision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/LEzTGnc4FZo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/LEzTGnc4FZo&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Misunderstood of same-origin policy</title>
        <link>https://truealarm.github.io/p/misunderstood-of-same-origin-policy/</link>
        <pubDate>Wed, 21 Dec 2022 02:05:26 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/misunderstood-of-same-origin-policy/</guid>
        <description>&lt;p&gt;Same-origin policy는 인터넷 브라우저와 같이 http 서버와 통신하는 웹 애플리케이션이 사용하는 보안 정책의 한 종류이다. 현대의 브라우저라면 필수적으로 적용하는 정책으로, 웹 페이지에서 스크립트를 통해 다른 웹 페이지의 컨텐츠를 읽을 때 Origin이 같은 경우만 허용하는 정책이다.&lt;/p&gt;
&lt;h2 id=&#34;the-origin&#34;&gt;The Origin&lt;/h2&gt;
&lt;p&gt;한국어로 기원, 근원을 의미하는 Origin이라는 단어는 Same-origin policy에서 정확히 어떤 의미를 사용되고, 왜 필요한건지 알 필요가 있다.&lt;/p&gt;
&lt;p&gt;기본적으로 HTTP 프로토콜로 통신하는 클라이언트와 서버는 매 연결마다 새로운 연결을 시도한다. 때문에 웹 사이트에 로그인한 유저의 상태를 계속 유지하는 것처럼, 이전 HTTP 요청에 대한 정보를 유지하고 싶으면 Cookie에 세션 아이디를 저장하는 방식을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;브라우저는 스크립트를 통해 시작된 HTTP 요청에도 Cookie를 리퀘스트 헤더에 포함하고, Cookie에는 세션 정보를 포함하고 있으므로, 서버는 로그인한 유저라고 간주한 채 요청을 처리하고 리스폰스를 반환한다. 이때 아무런 제약 없이 리스폰스를 읽을 수 있다면, 심각한 보안 위협으로 이어질 수 있다.&lt;/p&gt;
&lt;p&gt;악의적인 웹 사이트(evil.com)의 운영자가 선량한 웹 사이트의 민감 정보를 반환하는 API(bank.com/myinfo)를 요청하고, 이 결과를 다시 본인의 서버로 전송하는 스크립트(아래 코드 참고)를 웹 사이트에 포함시켜 놓으면, 선량한 웹 사이트에 로그인한 유저가 evil.com에 방문하는 것만으로도 민감 정보가 유출된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&amp;lt;!-- evil.com --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;onreadystatechange&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readyState&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;DONE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;sendToEvil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;responseText&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;bank.com/myinfo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이를 막기 위해 필요한 정보가 Origin이다. Origin은 브라우저가 스크립트를 통해 HTTP 요청을 시작할 때 해당 스크립트가 실행된 장소를 의미한다. 그리고 장소는 schema, hostname, port 정보를 합쳐 표현한다. (i.e., schema://hostname:port)&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code&gt;http://www.example.com:8080/hello&lt;/code&gt; 에서 &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;fetch&lt;/a&gt;로 &lt;code&gt;http://www.naver.com&lt;/code&gt; 사이트를 읽어오면 Origin은 &lt;code&gt;http://www.example.com:8080&lt;/code&gt; 가 되는 것이다. &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Host&lt;/a&gt; 혹은 &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Referer&lt;/a&gt;와 비슷하지만 Host는 schema를 포함하지 않고, Referer는 path까지 포함하는 정보이다.&lt;/p&gt;
&lt;h2 id=&#34;how-to-work&#34;&gt;How to work&lt;/h2&gt;
&lt;p&gt;브라우저가 스크립트를 통해 HTTP 요청을 시작할 때 schema, host, port 정보로 Origin을 만들고, 이 정보를 HTTP 요청마다 Origin 헤더로 추가한다. 서버는 요청을 처리한 뒤, 리스폰스 헤더에 해당 Origin이 리스폰스를 읽을 수 있는지 여부를 표시한다. 이후 브라우저에서 리스폰스에 표시가 없다면 스크립트에서 접근을 제한한다.&lt;/p&gt;
&lt;p&gt;크롬이나 사파리 같은 메이저 브라우저에서 다른 Origin의 웹 사이트를 요청하는 코드를 실행해보면 에러가 반환되는 것을 확인할 수 있다. 서버에서 명시적으로 특정 Origin을 허용하도록 설정해주지 않으면, 리소스에 대한 접근이 불가능한 것이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://example.com&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xhr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Access to XMLHttpRequest at &amp;#39;https://example.com/&amp;#39; from origin &amp;#39;https://stackoverflow.com&amp;#39; has been blocked by CORS policy: No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// GET https://example.com/ net::ERR_FAILED 200
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;jsonp&#34;&gt;JSONP&lt;/h2&gt;
&lt;p&gt;Same-origin policy는 스크립트를 통해 생성된 HTTP 요청에만 적용되고, 다른 도메인의 이미지, CSS나 스크립트 파일을 로드하면서 발생하는 HTTP 요청은 해당되지 않는다. 이런 특성은 강제적인 Same-origin policy의 제한을 예외적으로 허용하고 싶을 때, (i.e., 서로 다른 서브 도메인 간 리소스 공유) 활용될 수 있고, 이를 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/JSONP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JSONP&lt;/a&gt; (JSON with Padding)라고 부른다.&lt;/p&gt;
&lt;p&gt;현재의 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CORS&lt;/a&gt; (Cross-Origin Resource Sharing)가 널리 사용되기 전인 2005년에 Bob Ippolito에 의해 고안된 방법으로, script의 src에 요청할 다른 도메인의 서버의 주소를 지정하고, 해당 서버에서는 JSON 형식의 리스폰스를 callback 함수의 인자로 호출하는 스크립트 소스 형태로 반환하는 것이다. (아래 코드 참고) 서로 다른 Origin 간 HTTP 요청이지만, 스크립트 로드를 통해 읽어온 데이터이므로 Same-origin policy에 위배되지 않고 Cross-Origin Resource Sharing이 가능하다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;application/javascript&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;na&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;http://bank.com/myinfo?callback=checkAccount&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Response of http://example.com/myinfo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;checkAccount({&amp;#34;name&amp;#34;: &amp;#34;Alice&amp;#34;, &amp;#34;id&amp;#34;: 1234});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;illusions&#34;&gt;Illusions&lt;/h2&gt;
&lt;h3 id=&#34;cant-we-set-the-origin-header&#34;&gt;Can&amp;rsquo;t we set the Origin header?&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin#description&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;모질라 문서&lt;/a&gt;에 따르면 브라우저는 아래와 같은 요청에는 무조건 Origin 헤더를 추가한다. 그래서 Origin 헤더를 임의로 설정한 뒤 &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;XMLHttpRequest&lt;/a&gt;를 실행해도 브라우저가 알아서 덮어씌우므로 변조할 수 없다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Glossary/CORS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cross origin&lt;/a&gt; requests.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;same-origin&lt;/a&gt; requests except for &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; requests (i.e. they are added to same-origin &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;PATCH&lt;/code&gt;&lt;/a&gt;, and &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests).&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;📝 &lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Origin 헤더 말고 스크립트에서 덮어씌울 수 없는 헤더 목록은 &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Forbidden header name&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Origin 헤더를 추가하는 정책은 &lt;a class=&#34;link&#34; href=&#34;https://www.rfc-editor.org/rfc/rfc6454#section-7.3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;rfc 문서&lt;/a&gt;의 &amp;ldquo;7.3 User Agent Requirements&amp;rdquo; 부분을 읽어보면 Same-origin policy를 위한 필수적인 요구 사항임을 알 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The user agent MAY include an Origin header field in any HTTP
request.&lt;/li&gt;
&lt;li&gt;The user agent MUST NOT include more than one Origin header field in
any HTTP request.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;물론 Burp Suite 같은 Web proxy를 통해 HTTP 요청을 intercept 한다면 Origin 헤더를 변조할 수 있다. 근데 이런 방식으로 HTTP 요청을 감청하여 Origin을 변경할 수 있는건 MITM이 가능하다는 전제이므로 고려하지 않는다. Same-origin policy는 악성 웹 사이트의 관리자가 스크립트 코드를 통해 다른 웹 사이트의 리소스를 읽을 수 없도록 막아준다. 애초에 MITM이 가능하다면 Origin을 변경하여 Same-origin policy가 우회되는 것은 신경쓰지 않아도 될 정도로 심각한 공격이 가능하다.&lt;/p&gt;
&lt;h3 id=&#34;can-same-origin-policy-prevent-csrf&#34;&gt;Can same-origin policy prevent CSRF?&lt;/h3&gt;
&lt;p&gt;Same-origin policy가 &lt;a class=&#34;link&#34; href=&#34;https://owasp.org/www-community/attacks/csrf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CSRF&lt;/a&gt; 공격까지 막을 수 있을까? 라는 질문에 꽤 많은 사람들이 막을 수 있다고 생각한다. 결론부터 말하면 절반 정도 맞는 말이다. Same-origin policy이 다른 Origin에 대한 HTTP 요청을 막아준다고 착각해서 악의적인 웹 사이트에서 정상적인 웹 사이트로 변조된 요청을 보내는 CSRF 공격을 막을 수 있다고 믿는다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Same-origin policy는 웹 페이지에서 스크립트를 통해 다른 웹 페이지의 &lt;strong&gt;컨텐츠를 읽을 때&lt;/strong&gt; Origin이 같은 경우만 허용하는 정책이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;해당 포스트의 첫 문단에서 설명한 대로 &lt;strong&gt;Same-origin policy는 HTTP 요청을 막는 게 아니라 요청 결과에 접근하지 못하도록 막는 것이다.&lt;/strong&gt; 요청 자체를 막으려면 서버에서 Origin을 확인하고 요청을 거부하거나, 브라우저에서 실제 요청을 보내기 전에 서버에게 허용된 Origin이 맞는지 확인하는 과정이 필요하다.&lt;/p&gt;
&lt;p&gt;CSRF 공격을 막을 수 있다는 말이 절반정도 맞는 이유는 CSRF를 막기 위해 흔히 사용되는 &lt;a class=&#34;link&#34; href=&#34;https://portswigger.net/web-security/csrf/tokens&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CSRF token&lt;/a&gt; 같은 방어책이 Same-origin policy에 의존하기 때문이다. 서버에서 웹 페이지를 제공하기 전에 랜덤한 값(CSRK token)을 생성하여 유저의 세션에 저장하고, 웹 페이지에 존재하는 input form에 포함시킨 채로 제공한다. 그러면 요청이 전송될 때 토큰이 같이 전송되고 서버에서 세션에 저장된 토큰과 비교하여 위조된 요청인지 확인한다.&lt;/p&gt;
&lt;p&gt;만약 Same-origin policy가 보장되지 않는다면 공격자는 웹 페이지에 포함되어 있는 토큰 값을 읽을 수 있으니 CSRF 공격을 막을 수 없다.&lt;/p&gt;
&lt;h3 id=&#34;can-custom-headers-prevent-csrf&#34;&gt;Can custom headers prevent CSRF?&lt;/h3&gt;
&lt;p&gt;세션 아이디를 Cookie가 아닌 Custom header를 통해 전달하도록 서버를 구성하면 일부 CSRF 공격을 막을 수 있다. 이 방법은 CSRF token 같이 웹 페이지나 세션 정보에 토큰을 저장하지 않는 장점이 있다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;XMLHttpRequest.setRequestHeader&lt;/a&gt; 공식 문서를 참고하면 다른 도메인에 대한 HTTP 요청에 Custom header를 추가하면 Same-origin policy에 의해 요청이 중단된다고 나와있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; For your custom fields, you may encounter a &amp;ldquo;&lt;strong&gt;not allowed by Access-Control-Allow-Headers in preflight response&lt;/strong&gt;&amp;rdquo; exception when you send requests across domains. In this situation, you need to set up the &lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; in your response header at server side.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그래서 &lt;code&gt;setRequestHeader(&amp;quot;x-custom-header&amp;quot;, &#39;abc&#39;)&lt;/code&gt;로 헤더를 추가하여 요청을 보내면 OPTIONS 메소드로 먼저 요청을 보내 허용된 Origin인지 확인하는 과정(pre-flight CORS check)이 추가된다. 하지만 XHR이나 AJAX를 사용하는 API 요청에만 적용할 수 있고, form 태그를 통한 요청에는 적용할 수 없다. 그리고 pre-flight CORS check를 위한 CORS 설정도 따로 관리해줘야 하므로 오히려 비용이 증가할 수 있다.&lt;/p&gt;
&lt;p&gt;물론 Same-origin policy에 의존하지 않는 방법도 있다. Cookie에 samesite 보안 옵션을 추가하면 다른 Origin에서 보낸 HTTP 요청에는 Cookie가 같이 포함되지 않아 CSRF를 막을 수 있고, CAPTCHA 같이 유저 인터랙션을 강제하는 방법으로 막을 수도 있다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Mutex in a nutshell</title>
        <link>https://truealarm.github.io/p/mutex-in-a-nutshell/</link>
        <pubDate>Sun, 20 Nov 2022 03:54:03 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/mutex-in-a-nutshell/</guid>
        <description>&lt;p&gt;mutex(Mutual execlusion)은 다수의 프로세스나 스레드가 공유하는 자원을 안전하게 사용(concurrent control)할 수 있도록 해주는 기술이다. 상호 배제라는 직역의 의미대로 한 스레드가 이미 임계 영역에 진입했다면 다른 스레드가 임계 영역에 진입하지 못하도록 막아준다. mutex의 원리나 필요성을 제대로 이해하지 않고 멀티스레드 프로그래밍을 한다면, &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Race_condition&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Race condition&lt;/a&gt; 같은 문제가 발생한다.&lt;/p&gt;
&lt;h2 id=&#34;race-condition&#34;&gt;Race condition&lt;/h2&gt;
&lt;p&gt;여러 스레드가 공유 데이터에 접근하는 임계 영역을 제한하지 않을 때 발생하는 Race condition 문제의 예시는 다음과 같다. 아래 그림처럼 i-1, i, i+1, i+2 노드가 연결된 싱글 리스트에서 i 노드를 삭제하려면, i-1 노드의 next 주소를 i+1 주소로 변경하는 코드를 통해 i 노드를 제거한다. 문제는 2개의 쓰레드가 각각 i 노드와 i+1 노드를 동시에 삭제를 시도하는 경우 의도와 달리 i+1 노드가 삭제되지 않는 결과가 나타난다. 이런 결과가 발생한 이유는 첫 번째 스레드가 노드를 완전히 삭제하기 전에, 두 번째 스레드도 삭제를 시도하였고, 스레드 간의 어떠한 협의나 규약 없이 임계 영역의 삭제 코드를 실행해서 그렇다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Mutual_exclusion_example_with_linked_list.png/1600px-Mutual_exclusion_example_with_linked_list.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Race condition 문제가 무서운 이유는 잘못된 concurrent operation을 수행하는 코드로 인해 뜻밖의 코드에서 런타임 에러가 발생하거나, 오히려 런타임 에러 없이 정상적으로 종료돼 문제가 발생한 사실조차 알아차리기 힘들기 때문이다. 게다가 Race condition은 크리티컬한 취약점으로 귀결될 가능성이 높다. 보통 웹 백엔드 서버의 경우 쿠폰 중복 사용, 이중 출금 등 금전적인 손해를 유발하는 취약점이 있고, 네이티브한 프로그램에서는 경계 검사 우회, UAF와 같은 취약점으로 이어져 메모리 보호 기법을 우회하는데 이용될 수 있다.&lt;/p&gt;
&lt;p&gt;개인적으로 골치 아프다고 생각했던 이유는 그날의 운에 따라 Race condition이 발생할 수도 있고 안할 수도 있다는 특징 때문이다. Race condition은 2개 이상의 스레드가 동시에 임계 영역에 접근할 때 발생하는 문제여서, 운이 좋게 각각의 스레드가 임계 영역을 차례대로 실행한다면 아무런 문제가 발생하지 않는다. 스레드의 실행 순서와 선점(preemption)은 운영체제에서 스케쥴링하고, CPU 코어 수나 스레드 우선 순위, I/O 블록 여부에 따라 순서가 크게 달라지므로 그야말로 복불복이다. (물론 모든게 알고리즘에 의해 결정되므로 엄밀히 따지면 복불복은 아니지만, 애플리케이션 레벨에서는 제멋대로 실행되는 것처럼 보인다)&lt;/p&gt;
&lt;p&gt;Race condition을 악용하려는 공격자는 보통 단 시간내 최대한 많은 쓰레드가 임계 영역에 접근하도록 유도하여 고의적으로 문제를 유발한다. 이런 이유로 테스트 코드만으로는 Race condition을 발견하기 힘들고, 실제 서비스가 프로덕션으로 배포되고 사용자가 충분히 많아진 시점에서 발견된다.&lt;/p&gt;
&lt;h2 id=&#34;mutual-exclusion&#34;&gt;Mutual Exclusion&lt;/h2&gt;
&lt;p&gt;mutex의 공유 자원 관리는 총 4가지 상태로 나누어 진행할 수 있는데, 임계 영역으로 진입을 시도하는 Trying 상태, 임계 영역에 진입한 Critical 상태, 임계 영역의 실행이 끝나 다른 스레드에게 차례를 넘겨주는 Exit 단계, 마지막으로 임계 영역 이외의 공유 자원에 접근하지 않는 Remainder 상태가 있다. 노드를 삭제하는 코드 영역을 임계 영역으로 설정하고, 다음과 같은 과정을 통해 임계 영역에 하나의 스레드만 진입하게 할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;스레드가 노드를 삭제하는 코드(임계 영역)에 도달하면 Remainder 상태에서 Trying 상태로 전환.&lt;/li&gt;
&lt;li&gt;임계 영역에 진입한 스레드가 없으면 Critical 상태로 전환. 있으면 대기. (모든 작업이 일련에, atomic하게 처리되어야 함)&lt;/li&gt;
&lt;li&gt;Critical 상태의 스레드가 노드를 완벽히 삭제한 후 Exit 상태로 전환하여, 다른 스레드가 임계 영역을 실행할 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;삭제를 끝낸 스레드는 Reminder 상태로 돌아가 임계 영역 이외의 코드를 실행.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;deadlock-freedom&#34;&gt;Deadlock Freedom&lt;/h2&gt;
&lt;p&gt;mutex를 적용했을 때 보장되어야 하는 특성 중 임계 영역에서 스레드를 상호 배제시켜 주는 mutual exclusion 이외의 중요한 특성이 하나 더 있다. 모든 스레드가 Trying 상태에서 빠져 나가지 못하게 되어 임계 영역의 코드를 실행할 수 없는, 다시 말해 프로세스의 아무런 진전이 없는 교착 상태(&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Deadlock&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Deadlock&lt;/a&gt;)가 발생하지 않도록 보장해야 한다. 한 스레드가 Trying 상태에서 무한히 기다리고 있다면, 어떤 스레드는 임계 영역에 이미 진입한 상태임을 항상 보장하는 특성이 Deadlock Freedom 이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://truealarm.github.io/p/mutex-in-a-nutshell/mutex.png&#34;
	width=&#34;581&#34;
	height=&#34;480&#34;
	srcset=&#34;https://truealarm.github.io/p/mutex-in-a-nutshell/mutex_huc88058e091310d3a445f7ed1441ef26d_8588_480x0_resize_box_3.png 480w, https://truealarm.github.io/p/mutex-in-a-nutshell/mutex_huc88058e091310d3a445f7ed1441ef26d_8588_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2개의 스레드가 임계 영역을 교차로 접근하는 경우&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;290px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;그렇다면 위와 같이 각각의 스레드가 2개의 mutex를 사용하는 경우를 생각해보자. 1,2번 스레드가 각각 1,2번 임계 영역에 진입한 후에 다른 임계 영역으로 진입을 시도한다면, 이미 서로 진입했던 임계 영역이라 무한 루프에 빠지게 된다. 위 상황처럼 임계 영역에 진입한 스레드가 무한 루프에 빠지거나, 모종의 이유로 Exit 상태로 전환되지 않아 모든 스레드가 영원히 대기하더라도 Deadlock Freedom은 만족하는 것이다. 1,2번 스레드 모두 아무런 진전이 없는 Deadlock 상태처럼 보이지만, 이미 Trying 상태를 벗어나 1,2번 임계 영역에 진입한 이후다. 따라서 무한 루프를 발생시키는 코드라 할 지라도 임계 영역의 코드를 실행하고 있으므로 진전이 있다고 말할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;lockout-freedom&#34;&gt;Lockout Freedom&lt;/h2&gt;
&lt;p&gt;Deadlock Freedom을 만족하더라도 우선 순위가 높은 스레드가 임계 영역에 반복적으로 여러번 접근하면 해당 스레드만 계속 점유하는 현상이 발생할 수 있다. 우선 순위가 낮은 스레드는 계속 Trying 상태로 머무르는 기아 상태(&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Starvation_%28computer_science%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Starvation&lt;/a&gt;)에 빠질 수 있는 것이다. Deadlock Freedom에서 확장되어 임계 영역에 진입하고자 하는 Trying 상태의 스레드가 유한한 시간 내에 임계 영역에 진입하여 기아 상태가 발생하지 않도록 보장하는 특성을 Lockout Freedom 이라고 부릅니다. Lockout Freedom은 mutex의 필수 특성은 아니다.&lt;/p&gt;
&lt;h2 id=&#34;hardware-implemenation&#34;&gt;Hardware implemenation&lt;/h2&gt;
&lt;p&gt;하드웨어 기반으로 mutex를 구현하는 방법 중 가장 간단한 방법은 임계 영역에 진입하기 전에 interrupt를 비활성화해 cpu가 context swithch을 하지 못하게 만드는 방법이다. interrupt가 발생하지 않으면 스레드나 프로세스의 실행이 스케쥴링되지 않으므로, 임계 영역 실행 도중에 다른 스레드가 선점하지 못하게 막을 수 있지만 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Uniprocessor_system&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Uniprocesser&lt;/a&gt;에서만 가능하다. Multiprocessor는 각각의 cpu가 병렬적으로 실행되므로, interrupt가 비활성화되지 않은 다른 cpu가 임계 영역에 진입할 수 있다. 물론 모든 프로세서의 interrupt를 비활성화하면 되지만, 다른 프로세스의 interrupt 설정까지 변경하기 힘들고 성능이 매우 저하되므로 비싼 multiprocessor를 사놓고 할 짓은 아니다. 게다가 임계 영역에 머무르는 동안 interrupt를 비활성화하면 시간 정보(system clock)을 가져오지 못하거나, 임계 영역에서 다시 interrupt 설정을 복구하지 못하고 종료되면 전체 시스템의 장애로 이어지는 단점이 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TestAndSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;boolean_ref&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;initial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;initial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이런 한계점을 극복하기 위해 공유 메모리와 read-modify-write 명령어를 통해 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Busy_waiting&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Busy-waiting&lt;/a&gt; 시스템을 구현한다. read-modify-write 명령어에 속하는 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Test-and-set&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;test-and-set&lt;/a&gt; 명령어는 위 코드와 같이 스레드가 공유하는 메모리에서 초기 lock 상태를 읽어온 뒤, lock 상태를 true로 설정하고 초기 lock 상태를 반환하는 기능을 수행한다. 당연히 하드웨어에서 이 모든 작업을 atomic하게 수행할 수 있는 단일 어셈블리를 지원해야 한다. 명령어의 반환 값이 false면 임계 영역에 진입하고, true면 다른 작업을 수행하거나 루프를 돌며 차례를 기다리는 방식으로 mutex를 구현할 수 있다. 이 과정을 코드로 표현하면 아래와 같다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// state: Remainder
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;remainder&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// state: Trying
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TestAndSet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// state: Critical
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// state: Exiting
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;공유 메모리로 생성한 lock의 상태를 읽고, 변경하는 과정을 모두 atomic하게 수행하므로 임계 영역에 항상 하나의 스레드만 진입하는 것을 보장할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📝 &lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;임계 영역에 진입하기 위해 루프를 돌며 차례를 기다리는 방식을 spinlock이라고 부른다. 다른 스레드로 context switch하고, 나중에 다시 context를 restore 하는 과정을 거치지 않고, 짧은 시간동안 차례를 기다려 오버헤드를 최소화한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위 방식은 mutex의 기본 조건은 모두 만족하지만, lockout freedom은 만족하지 않는다. 그래서 만약 특정 스레드가 빠르게 lock을 set하고 reset하는 과정을 반복한다면, 다른 스레드는 임계 영역에 진입하지 못하게 되는 starvation이 발생하고, 이로 인해 몇몇 스레드의 성능이 비정상적으로 떨어질 수 있다.&lt;/p&gt;
&lt;p&gt;이를 해결하려면 스레드의 도착 순서를 기록하면 되고, atomic queue를 통해 1) Trying 시점에 스레드 id를 enquque, 2) queue의 head 값과 본인의 스레드 id가 일치할 때 임계 영역에 진입, 3) Exiting 시점에 dequeue하면 된다. atomic queue를 사용하는 이유는 enqueue, dequeue 할 때 race condition이 발생하지 않게 하기 위함이다. (atmoic queue는 mutex와 달리 lock에 의존적이지 않도록 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Compare-and-swap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;compare-and-swap&lt;/a&gt; 명령어를 통해 Non-blocking 자료구조로 구현한다)&lt;/p&gt;
&lt;h2 id=&#34;software-implemenation&#34;&gt;Software implemenation&lt;/h2&gt;
&lt;p&gt;test-and-set 명령어와 같이 하드웨어가 제공하는 atomic operation 없이 소프트웨어 구현으로만 mutex를 구현할 수 있는 여러 알고리즘이 존재한다. 알고리즘에 들어간 아이디어가 궁금하여 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Dekker%27s_algorithm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dekker&amp;rsquo;s algorithm&lt;/a&gt;과 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lamport&amp;rsquo;s bakery algorithm&lt;/a&gt;을 살펴보았다. 다만, 소프트웨어 알고리즘은 cpu 최적화 기법 중 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Out-of-order_execution&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Out-of-order execution&lt;/a&gt;이 적용되면 의도한 순서대로 순차적으로 명령어가 실행되지 않기에 문제가 발생할 수 있지만, &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Memory_ordering&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Memory ordering&lt;/a&gt;을 적용하여 해결할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;dekkers-algorithm&#34;&gt;Dekker&amp;rsquo;s algorithm&lt;/h3&gt;
&lt;p&gt;Dekker&amp;rsquo;s algorithms은 2개의 프로세스가 임계 영역에 동시에 접근해도 상호 베타적으로 실행되도록 보장하는 최초의 mutual execlusion 알고리즘이다. 프로세스는 임계 영역에 들어가겠다는 의도를 표현할 플레그 값(&lt;code&gt;will_enter&lt;/code&gt;)과, 임계 영역에 진입 가능한 프로세스를 나타나는 플레그 값(&lt;code&gt;turn&lt;/code&gt;)을 공유하는게 특징이다. Dekker&amp;rsquo;s algorithms을 슈도 코드로 구현해가며, 어떤 아이디어가 적용됐는지 살펴보겠다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Mutex version 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;** global variables: P0_enter, P1_enter 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Trying */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P1_enter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// [A]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;P0_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Critical */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Exiting */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위 코드는 첫 번째 프로세스(P0)가 사용하는 코드로, 임계 영역에 도달하면 &lt;code&gt;P1_enter&lt;/code&gt; 값을 읽어 상대 프로세스가 임계 영역에 이미 진입했는지 확인한다. 만약 없다면 곧바로 임계 영역으로 진입하고 &lt;code&gt;P0_enter&lt;/code&gt;을 true로 설정하여 임계 영역에 진입했음을 알린다. 임계 영역을 나가기 직전에 &lt;code&gt;P0_enter&lt;/code&gt; 값을 다시 false로 설정하여 P1에게 차례를 내준다.&lt;/p&gt;
&lt;p&gt;하지만 [A] 지점에서 &lt;code&gt;P0_enter&lt;/code&gt; 값을 true로 설정하는 코드가 실행되기 전에 context switch가 발생하여 P1이 선점한다면, 임계 영역에 2개의 프로세스 모두 진입하게 되는 race condition이 발생한다. 이를 막기 위해 &lt;code&gt;P0_enter&lt;/code&gt; 의 설정 시점을 아래와 같이 변경한다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Mutex version 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;** global variables: P0_will_enter, P1_will_enter 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Trying */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// [A]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P1_will_enter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Critical */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Exiting */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이제는 P0 프로세스가 임계 영역에 진입할 것이라는 의도를 나타내는&lt;code&gt;P0_will_enter&lt;/code&gt; 값에 true를 설정하고, &lt;code&gt;P1_will_enter&lt;/code&gt; 값을 확인하여 P1 프로세스가 임계 영역에 진입했는지 확인한다. 덕분에 두 개의 프로세스가 동시에 임계 영역에 접근할 가능성은 없어졌지만, [A] 지점에서 context switch가 발생하면 &lt;code&gt;P0_will_enter&lt;/code&gt;, &lt;code&gt;P1_will_enter&lt;/code&gt; 모두 true가 될 수 있어 아무도 임계 영역에 진입하지 못하는 교착 상태가 발생한다. 이는 mutex의 기본 조건인 deadlock freedom에 위배되는 구현이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Mutex version 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;** global variables: P0_will_enter, P1_will_enter, priority
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Trying */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P1_will_enter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;priority&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Critical */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Exiting */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;priority&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;deadlock 문제를 해결하기 위해 어떤 프로세스가 먼저 실행할 지 결정할 &lt;code&gt;priority&lt;/code&gt; 값을 추가한다. 만약 &lt;code&gt;P0_will_enter&lt;/code&gt;, &lt;code&gt;P1_will_enter&lt;/code&gt; 모두 true가 되어 두 개의 프로세스가 모두 while 문으로 진입하였더라도, 본인의 순서가 아니면 &lt;code&gt;will_enter&lt;/code&gt; 값을 false로 설정하고 차례를 기다린다. 따라서 하나의 프로세스는 while 문 밖으로 빠져나와 임계 영역을 진입하게 된다.&lt;/p&gt;
&lt;p&gt;여기까지 구현했다면 mutex로 사용하기 충분하지만, starvation으로부터 자유롭지 않으므로 공정성(fairness)을 높이기 위한 조치를 취할 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Mutex version 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;** global variables: P0_will_enter, P1_will_enter, priority
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Trying */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P1_will_enter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;priority&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;priority&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Critical */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* State: Exiting */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;priority&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;P1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;P0_will_enter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;←&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;첫 번째 while 문에서 &lt;code&gt;priority&lt;/code&gt; 값을 비교해 본인의 순서인지 확인하고, 본인의 순서라도 deadlock에 빠지지 않기 위해 다른 프로세스가 &lt;code&gt;will_enter&lt;/code&gt;를 false를 설정하는 것을 기다린다. 안쪽의 while 문은 본인의 순서가 아닌 상태에서 다른 프로세스가 임계 영역에서 빠져나가는 것을 기다리는 루프이다. 이렇게 현재 &lt;code&gt;priority&lt;/code&gt;에 따라 목적에 맞는 spin을 선택하도록 하면 공정성을 좀 더 높일 수 있다. 위처럼 mutual exclusion, deadlock freedom, starvation freedom까지 고려한 알고리즘이 바로 Dekker&amp;rsquo;s algorithm 이다.&lt;/p&gt;
&lt;h3 id=&#34;lamports-bakery-algorithm&#34;&gt;Lamport&amp;rsquo;s bakery algorithm&lt;/h3&gt;
&lt;p&gt;Dekker&amp;rsquo;s algorithm은 2개의 프로세스가 임계 영역에 접근하는 경우만 고려하였기 때문에, 수십개 이상의 프로세스와 스레드가 동시에 실행되는 상황에서 적용하기 힘들다. 반면에 Lamport&amp;rsquo;s bakery algorithm은 2개 이상의 스레드가 동시에 실행되는 환경에서도, 완벽하게 임계 영역에 진입할 스레드를 결정하여 동시성 프로그래밍을 가능하게 한다.&lt;/p&gt;
&lt;p&gt;Lamport&amp;rsquo;s bakery algorithm이 상호 배제를 위해 채택한 방식은 실생활의 번호표 대기 시스템과 비슷하다. 은행에서 동시간대 몰린 고객들을 관리할 때 입구에서 고객마다 번호표를 뽑도록 하고, 대기실 모니터에 현재 상담 중인 번호를 알려준다. 상담이 끝나 고객이 창구를 나가면, 현재 번호에 1을 더하고 대기하던 고객들은 모두 자신의 번호표에 적힌 번호를 통해 차례를 확인하여 일치하면 상담 창구로 들어간다. 여기서 고객을 하나의 스레드로 생각하고 알고리즘을 구현하면 된다.&lt;/p&gt;
&lt;p&gt;하지만 컴퓨터 세계에서 모든 스레드가 사이좋게 중복되지 않은 번호표를 뽑는 것을 기대할 수 없다. 만약 여러 스레드가 중복되지 않은 번호표를 뽑는게 가능하다면, Lamport&amp;rsquo;s bakery algorithm을 통해 해결하고자 하는 상호 배제 문제를 해결할 필요가 없다. 왜냐하면 여러 개의 스레드가 동시에 번호표를 발급받는 상황에서 atomic operation이나 mutex를 통해 동시성 프로그래밍을 하지 않으면, 같은 번호를 발급받게 되는 상황이 생길 수 있기 때문이다. 그래서 Lamport&amp;rsquo;s bakery algorithm은 프로세스가 같은 번호표를 뽑는 상황에 대비하여 스레드마다 갖는 고유한 아이디를 활용한다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Mutex version 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   global variables:  Number[1..NUM_THREADS] = {0};
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NUM_THREADS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [A]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM_THREADS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Wait until all threads with smaller numbers or with the same
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// number, but with higher priority, finish their work:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [B]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// non-critical section...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위 코드가 지금까지 설명한 내용을 토대로 Lamport&amp;rsquo;s bakery algorithm를 구현한 코드이다. &lt;code&gt;lock&lt;/code&gt; 함수는 스레드가 번호표를 뽑고 [A], 자신의 번호를 계속 확인하다 차례가 오면 [B], 임계 영역에 진입하는 함수이고, &lt;code&gt;unlock&lt;/code&gt; 함수는 임계 영역에서 빠져나올 때 실행하는 함수이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;lock&lt;/code&gt; 함수에서 두 번째 while 문을 통해 실행하는 위 코드가 어떤 스레드가 임계 영역에 들어갈 차례인지 결정하는 코드인 동시에 모두가 차례대로 임계 영역에 접근하기 위해 따르는 규칙이다. &lt;code&gt;Number&lt;/code&gt; 배열은 모든 스레드가 공유하는 변수이며 스레드 아이디를 인덱스로 사용하여 스레드가 발급받은 번호를 저장한다. 전체 스레드 갯수만큼 반복문을 돌며, 다른 스레드의 번호가 내 번호보다 작은지 비교한다. 작다면 해당 스레드가 먼저 번호표를 뽑은 스레드이므로 spin을 돌며 기다린다. 번호표를 뽑은 스레드 중 가장 작은 번호의 스레드가 임계 영역을 실행하고 나가면서 &lt;code&gt;unlock&lt;/code&gt; 함수를 호출하므로, 다음으로 작은 번호표를 뽑은 스레드가 spin에서 빠져나와 임계 영역으로 진입한다.&lt;/p&gt;
&lt;p&gt;처음에 설명한대로 서로 다른 스레드가 동시에 [A] 지점의 코드를 실행하면, 같은 번호를 갖는 경우가 생길 수 있어 번호가 같은 경우도 대비해야 한다. 그래서 &lt;code&gt;Number&lt;/code&gt; 정보가 같은 경우, 스레드마다 고유한 아이디인 i, j를 비교하여 더 작은 아이디의 스레드가 임계 영역에 진입한다. 이제 더이상 고려해야 하는 문제가 없어보이지만, 해당 구현에는 큰 결함이 하나 존재한다.&lt;/p&gt;
&lt;p&gt;만약 어떤 스레드가 [A]에서 최대값을 &lt;code&gt;Number[i]&lt;/code&gt;에 저장하기 직전에 context switching이 발생한다면, 다른 스레드가 [B]에서 &lt;code&gt;Number&lt;/code&gt; 값을 제대로 비교할 때 이를 확인할 방법이 없다. (최대값을 계산하고 저장하는 코드는 atomic하게 실행되지 않으므로 이런 상황이 발생할 수 있다) 이게 문제가 될 수 있는 상황은 다음과 같다.&lt;/p&gt;
&lt;p&gt;1번 스레드가 &lt;code&gt;Number[1]&lt;/code&gt;에 번호를 저장하기 직전에 2번 스레드가 선점한다면 1,2번 스레드는 같은 번호를 가지게 된다. 이후로 2번 스레드는 1번 스레드가 아직 &lt;code&gt;Number[1]&lt;/code&gt;에 번호를 저장하지 않은 사실은 모른채, while문을 통해 모든 스레드의 번호를 확인하고 본인의 번호가 가장 작은걸 확인하고 임계 영역으로 진입한다. 이때 1번 스레드가 다시 실행되어 &lt;code&gt;Number[1]&lt;/code&gt;에 번호를 저장하고 while문을 통해 모든 스레드의 번호를 확인하지만, 2번 스레드보다 본인의 아이디가 더 작은걸 확인하고 임계 영역에 진입한다. 결국 2개의 스레드가 모두 임계 영역에 들어가는 사태가 발생한다.&lt;/p&gt;
&lt;p&gt;Lamport&amp;rsquo;s bakery algorithm에서는 이런 문제를 해결하려고 임계 영역에 진입하려는 스레드가 번호를 완전히 저장했는지 확인할 목적으로 &lt;code&gt;Entering&lt;/code&gt; 변수를 추가하였다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Mutex version 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   global variables:  Entering[1..NUM_THREADS] = {false};
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;                      Number[1..NUM_THREADS] = {0};
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Entering&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NUM_THREADS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Entering&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM_THREADS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Wait until thread j receives its number:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entering&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* wait */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [C]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// Wait until all threads with smaller numbers or with the same
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// number, but with higher priority, finish their work:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* spin */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [D]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// non-critical section...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;Number[i]&lt;/code&gt;를 저장하기 전에 &lt;code&gt;Entering[i]&lt;/code&gt;에 true를, 저장이 완료되면 false를 설정하는 코드랑 &lt;code&gt;Entering[j]&lt;/code&gt;가 false가 될 때까지 기다리는 [C] 코드가 추가됐다. [C]에 추가된 반복문이 &lt;code&gt;Entering[j]&lt;/code&gt;가 false가 될 때까지 기다리므로, [D]에서 다른 스레드의 번호를 비교하는 시점에는 &lt;code&gt;Number&lt;/code&gt;에 값을 저장하지 않은 스레드를 걱정하지 않아도 됩니다.&lt;/p&gt;
&lt;p&gt;이렇게 구현한 Lamport&amp;rsquo;s bakery algorithm은 Dekker&amp;rsquo;s algorithm과 마찬가지로 mutual exclusion, deadlock freedom, lockout freedom을 만족합니다. 게다가 모든 스레드는 먼저 온 순서대로 번호를 부여받고, 임계 영역에 진입하므로 높은 fairness를 갖는 알고리즘입니다.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Mutual_exclusion&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Mutual_exclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cs.yale.edu/homes/aspnes/pinewiki/MutualExclusion.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cs.yale.edu/homes/aspnes/pinewiki/MutualExclusion.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.qnx.com/developers/docs/6.3.2/neutrino/prog/overview.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.qnx.com/developers/docs/6.3.2/neutrino/prog/overview.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://helix979.github.io/jkoo/post/os-scheduler/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://helix979.github.io/jkoo/post/os-scheduler/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://lamport.azurewebsites.net/pubs/mutual2.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://lamport.azurewebsites.net/pubs/mutual2.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Archives</title>
        <link>https://truealarm.github.io/archives/</link>
        <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
        
        <guid>https://truealarm.github.io/archives/</guid>
        <description></description>
        </item>
        <item>
        <title>Search</title>
        <link>https://truealarm.github.io/search/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://truealarm.github.io/search/</guid>
        <description></description>
        </item>
        
    </channel>
</rss>
