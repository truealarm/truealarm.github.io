<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>TIL on True Alarm</title>
        <link>https://truealarm.github.io/categories/til/</link>
        <description>Recent content in TIL on True Alarm</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 23 Jan 2023 21:14:32 +0900</lastBuildDate><atom:link href="https://truealarm.github.io/categories/til/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Kotlin in Action: What and Why</title>
        <link>https://truealarm.github.io/p/kotlin-in-action-what-and-why/</link>
        <pubDate>Mon, 23 Jan 2023 21:14:32 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/kotlin-in-action-what-and-why/</guid>
        <description>&lt;p&gt;최근 &lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=_Of8e0o6u3U&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;kakao tech 유튜브 채널&lt;/a&gt;에서 카카오톡 메시징 시스템을 C++ 서버에서 Kotlin 서버로 재건축한 과정을 설명하는 영상을 봤다. 이미 오랜 기간 운영하던 C++ 서버를 드러내기로 결심한 이유가 가장 궁금했는데,  C++ 서버를 유지보수할 인력이 점점 줄어들고 있고 수년후에는 인력난이 더 심각해져 정상적인 운영이 불가능할 것 같아서 이런 결정을 내렸다고 영상에서 설명한다. 뿐만 아니라 다른 JVM 기반 서버와 호환성과 통신 과정에 대해 고려할 사항이 줄어들고, gc 정책을 변경한 뒤 벤치마크 테스트를 수행한 결과 기존 C++ 서버와 큰 성능 차이가 없었다고 한다.&lt;/p&gt;
&lt;p&gt;사실 영상을 보기 전부터 현업에서 Spring과 함께 활발하게 사용되는 언어라 깊이있게 공부할 필요성을 느꼈고, 개인적으로 Java/Kotlin 기반 서버가 왜 이렇게 인기가 많고, 왜 이곳저곳에서 사용되는지 궁금했다. 잠시 시간을 내서 Kotlin이 어떤 느낌의 언어인지만 살펴봤는데 주력 언어로 배우고 싶을 정도로 매력적인 언어라는 생각이 들었다. 그래서 &lt;a class=&#34;link&#34; href=&#34;https://www.amazon.com/Kotlin-Action-Dmitry-Jemerov/dp/1617293296&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kotlin In Action&lt;/a&gt; 서적을 시작으로 차근차근 공부해보려고 한다. 이번 포스트는 1,2 Chapter에 대한 내용을 다룬다.&lt;/p&gt;
&lt;h2 id=&#34;the-philosophy-of-kotlin&#34;&gt;The philosophy of Kotlin&lt;/h2&gt;
&lt;p&gt;Kotlin은 IntelliJ의 개발사인 JetBrains에서 만든 언어이며, JetBrains의 IDE 사용 데이터와 커뮤니티의 피드백을 반영하며 수년간 많은 변화를 겪다 출시되었다. 개발자들은 실용적(Pramatic)이고, 간결(Concise)하고, 안전(Safe)하면서 기존 Java와 상호 운용 가능(Interoperable)한 언어인 Kotlin을 탄생시켰다. 물론 자세히 배우지 않고는 이 4가지 특성이 어떻게 반영되고 있는지 모르겠지만, 몇가지 주요 특성만 살펴봐도 Koltin의 철학에 대해 공감할 수 있을 것이다. 개인적으로 Kotlin이 맘에 들었던 이유는 &lt;u&gt;&lt;strong&gt;Kotlin의 철학과 4가지 특성 모두 실제 현업에서 발생하는 비즈니스 문제 해결을 중시한다는 점이다.&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;그래서 Kotlin은 최첨단 컴파일러 기술을 통해 혁신적인 성능과 발전을 도모하기 보다, 이미 다른 언어에서 수년간 사용되며 좋다고 검증된 기술들을 모아 Kotlin 스타일로 녹이는 것에 집중한다. 아마 여러 언어를 배워본 사람이라면, 이후에 나오는 Kotlin 기능은 이미 다른 언어의 주력 기능임을 알아차릴 수 있을 것이다. (그래서 금방 배울 수 있다!)&lt;/p&gt;
&lt;p&gt;Kotlin은 직관적이고 가독성이 높은 코드를 작성하도록 설계되어 있고, Java와 달리 형식적으로 반복되는 코드가 필요없어 아주 간결한 코드를 짤 수 있는게 특징이다. 간결한 코드는 그만큼 우리가 읽어야 하는 코드의 양을 줄여주고, 가독성이 높은 코드는 기존 코드를 더욱 빨리빨리 읽을 수 있게 도와준다. 이는 개발자가 최대한 비즈니스 문제 해결에만 신경쓰면 된다는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;안전하다는 특성도 Kotlin의 장점을 부각시켜 주는 특성이다. Kotlin은 정적 타입 언어로 컴파일 타임에 모든 표현식의 타입이 결정된다. 그래서 컴파일 타임에서 타입 검사를 통해 최대한 많은 버그를 미리 잡아낼 수 있다. 물론 모든 변수나 표현식에 대해 자료형을 명시하지 않아도 컴파일러가 추론 가능한 경우는 자동으로 타입을 부여해주므로 개발자의 부담이 크게 늘어나지 않는다. 오히려 사소한 버그를 미연에 방지하여 불필요한 디버깅 시간을 줄일 수 있어 훨씬 이득이다. 또한 컴파일 타임에 모든 변수의 타입을 알 수 있기에 런타임 타입 검사를 제거하여 성능 향상을 노릴 수 있고, IDE에 타입 정보를 제공하여 더욱 스마트한 자동 완성 기능 등에 활용할 수 있다.&lt;/p&gt;
&lt;p&gt;안전성 관련해서 Kotlin은 null을 기본적으로 허용하지 않는 언어이기도 하다. 방심에서 비롯되는 수많은 널 포인터 참조 이슈와 같은 문제를 개발자가 방심하지 못하도록 막아주는 동시에, 깔끔하게 null을 처리할 수 있는 연산자나 구문을 제공하여 간결함을 침해하지 않는다.&lt;/p&gt;
&lt;p&gt;마지막으로 Kotlin은 기존 Java 코드와 완벽히 호환될 수 있어, Java 라이브러리를 그대로 사용할 수 있고, Java에서도 Kotlin 라이브러리를 사용할 수 있다. 그래서 Java가 사용되고 있는 모든 환경에서 Kotlin도 사용할 수 있다. 심지어 Java 파일과 Kotlin 파일을 같은 프로젝트에 포함시켜 개발할 수 있다. 이는 Java가 갖는 강력한 장점을 Kotlin도 누릴 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;h2 id=&#34;kotlin-basics&#34;&gt;Kotlin basics&lt;/h2&gt;
&lt;p&gt;Chapter 2는 Kotlin 언어의 핵심 기능과 기본적인 문법을 설명한다. 여기서 내가 따로 정리한 내용은 기본적인 문법에 대한 내용은 빼고, 내가 생각하기에 한번 더 언급할 만한 내용만 다뤘으니 자세한 내용은 서적을 참고하면 된다.&lt;/p&gt;
&lt;h3 id=&#34;statements-and-expressions&#34;&gt;Statements and Expressions&lt;/h3&gt;
&lt;p&gt;statement는 컴파일러가 이해할 수 있는 독립적인 코드 구문, 실행 과정에서 유의미한 효과를 발생시키는 구문을 의미하고, expression은 statement 중에서 실행 과정에서 값으로 평가될 수 있는 구문을 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val number = 1 // statement&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func(); // expression&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 예시에서 &lt;code&gt;val number = 1&lt;/code&gt; 문은 컴파일러가 이해할 수 있고 실행 시 변수를 선언하는 효과를 갖지만, 값으로 평가되지 않는 구문이다. 반면에 함수를 호출하는 &lt;code&gt;func()&lt;/code&gt; 구문의 경우는 실행 이후 함수의 반환값으로 값을 갖는 expression에 속한다.&lt;/p&gt;
&lt;p&gt;이 얘기를 꺼낸 이유는 Kotlin에서 반복문을 제외하고 if/else문, switch문, 심지어 try/catch 문 등의 block statement가 expression으로 처리되기 때문이다. 그래서 아래처럼 switch 구문이 값을 갖는 구문으로 평가될 수 있고, 대입문의 피연산자로 사용하는 등의 문법이 가능하다. C, C++, Java 같은 언어였다면 익명 함수(lambda)와 &lt;code&gt;return&lt;/code&gt; 구문을 통해 구현해야 하지만, Kotlin에서는 형식적인 코드가 전부 필요없어 간결하고, 오히려 가독성이 높은 코드로 구현있는 것이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;msg&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;OK&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;OK&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;400&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Bad Request&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;Bad Request&amp;#34; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;404&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Not Found&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;Not Found&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;N/A&amp;#34;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return &amp;#34;N/A&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;expression-bodies&#34;&gt;Expression bodies&lt;/h3&gt;
&lt;p&gt;Kotlin은 함수의 body를 expression으로만 구성하는게 가능하다. 아래 예시처럼 대입 연산자을 통해 expression이 평가된 값을 반환한다고 명시해주면 된다. if 문이 값을 가질 수 있는 expression임을 알고 있다면 return 구문을 통해 반환을 명시적으로 표현하지 않아도, 직관적으로 함수가 어떻게 동작하는지 이해할 수 있다. 간결함을 중요시하는 Kotlin과 아주 어울리는 문법이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;
&lt;p&gt;Object-oriented programming 언어라면 객체의 데이터(field)는 객체 안으로 집어넣고, 외부에서 직접 접근을 막는 캡슐화(Encapsulation) 원칙을 거의 무조건 고수한다. 내부 데이터인 field에 접근하거나 변경할 때는, field를 추상화한 property를 외부로 노출하고 이를 통해서만 접근하게 만들어 클래스 내부 정보를 최대한 숨긴다.&lt;/p&gt;
&lt;p&gt;Java에서 Class를 정의할 때는 private한 데이터(field)와 데이터 접근자(getter/setter)를 모두 구현해야 property를 정의할 수 있었다. (물론 Java 뿐만 아니라 많은 언어에서도 이런 방식을 많이 사용한다.) 반면에 Kotlin은 field와 accessor의 구분없이 Class에 선언된 변수는 전부 property로 처리된다. mutable한 property는 &lt;code&gt;var&lt;/code&gt;로 immutable한 property는 &lt;code&gt;val&lt;/code&gt;로 선언하면 된다. i.e. &lt;code&gt;var&lt;/code&gt; = writable, &lt;code&gt;val&lt;/code&gt; = readonly&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;isMarried&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;덕분에 field에 접근하는 getter/setter를 구현할 때 단순히 값을 반환/설정하는 형식적인 코드를 굳이 작성하지 않아도 된다. 당연히 getter/setter에서 값 검사와 같은 추가 로직이 필요한 경우 아래처럼 custom accessor를 사용하면 된다. (&lt;code&gt;get&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 키워드를 사용)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;area&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;enums-and-when&#34;&gt;Enums and &amp;ldquo;when&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;Kotlin에서 열거형(enum)은 단순히 type-safe한 일련의 숫자가 아니라, 클래스처럼 property와 method를 정의할 수 있고 초기화할 수 있는 객체이다. 그저 enum 상수의 열거가 끝나는 지점에 세미콜론만 붙여주면 된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;RED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;BLACK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rgb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;256&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;256&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;객체처럼 사용이 가능한 enum class는 기존 enum 상수보다 좀 더 유연하게 사용할 수 있고, when 구문과 같이 사용될 때 진가가 발휘된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;YELLOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ORANGE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;YELLOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BLUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GREEN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;setOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BLUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;VIOLET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INDIGO&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Dirty color&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Java의 switch 문에서 분기 조건 변수는 문자열, 열거형, 리터럴 등의 상수만 사용할 수 있지만, Kotlin의 switch 문인 when 구문은 연산식을 조건 변수로 사용할 수 있다. 위 예시에서 두 개의 색을 섞는 &lt;code&gt;mix&lt;/code&gt; 함수는 case 절마다 &lt;code&gt;setOf&lt;/code&gt; 함수가 실행된 결과와 &lt;code&gt;setOf(c1, c2)&lt;/code&gt;을 비교한다.&lt;/p&gt;
&lt;h3 id=&#34;smart-casts&#34;&gt;Smart casts&lt;/h3&gt;
&lt;p&gt;Kotlin은 컴파일러에게 특정 타입이라고 확정할 수 있는 정보가 제공된다면, 코드에서 굳이 형변환을 하지 않아도 되는 Smart cast를 지원한다. 무슨 기능인지 예제를 통해 살펴보자. &amp;ldquo;(1 + 2) + 3&amp;quot;과 같은 간단한 덧셈 연산식을 평가하는 프로그램을 구현한다고 했을 때, 연산식의 피연산자는 이진 트리의 노드로, 각각의 연산자는 &lt;code&gt;Expr&lt;/code&gt;를 상속한 &lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Sum&lt;/code&gt; 클래스로 정의할 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Expr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이 상황에서 연산식을 평가하는 &lt;code&gt;eval&lt;/code&gt; 함수는 인자로 전달된 Expr 클래스가 &lt;code&gt;Num&lt;/code&gt;인 경우는 숫자를 반환하고, &lt;code&gt;Sum&lt;/code&gt;인 경우는 더한 결과를 재귀 호출로 계산하여 반환하면 된다. ( &lt;code&gt;is&lt;/code&gt; 메소드는 Java에서 변수의 자료형을 반환하는 &lt;code&gt;instanceof&lt;/code&gt;과 같다고 보면 된다.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Unknown expression&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;위 함수에서 타입을 비교하는 if문 내부로 진입했다면 &lt;code&gt;e&lt;/code&gt;가 &lt;code&gt;Num&lt;/code&gt; 클래스인 것을 확정할 수 있지만, e가 Base 클래스인 &lt;code&gt;Expr&lt;/code&gt; 클래스로 전달됐기 때문에, &lt;code&gt;Num&lt;/code&gt; 클래스로 변환하고 있다. 만약 컴파일러가 좀 더 똑똑해서 if 문이 의미하는 바를 알아차렸다면, 유도리있게 &lt;code&gt;Num&lt;/code&gt;으로 간주할 수 있을 것이다. 이런 기능을 Smart cast라 부르고 Kotlin에서 지원하는 기능이다. 다만 위 경우처럼 if문을 통해 컴파일러가 명확하게 하나의 변수의 타입으로 추론할 수 있는 경우만 적용된다.&lt;/p&gt;
&lt;p&gt;expression body, when, smart cast을 통해 &lt;code&gt;eval&lt;/code&gt; 함수를 Kotlin 스타일로 바꾸면 아래처럼 훨씬 간결하게 짤 수 있다!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Unknown expression&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;참고로 expression으로 처리되는 if, when, try 구문에서 block을 통해 여러 줄을 구성한 경우, 해당 expression이 평가되는 값은 마지막 라인에 위치한 expression이 평가된 값이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Expr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;num: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${e.value}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;여기까지 1,2 Chapter를 읽고 다시 정리하기에 중요하다고 생각한 내용을 다루어봤다. 다음 포스트에선 Chapter 3인 &amp;ldquo;Defining and calling functions&amp;quot;를 읽고 정리할 예정이다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Mathematics For Computer Science: Propositions</title>
        <link>https://truealarm.github.io/p/mathematics-for-computer-science-propositions/</link>
        <pubDate>Sun, 22 Jan 2023 16:56:40 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/mathematics-for-computer-science-propositions/</guid>
        <description>&lt;p&gt;컴퓨터 사이언스를 공부할 때, 특히 알고리즘을 배울 때 수학이 나오면 학습 속도가 급격히 더져지고 결국 발목을 잡히곤 한다. 알고리즘의 타당성이나 시간복잡도를 증명 없이 넘어가면, 핵심을 이해하지 못하고 암기하고 있다는 느낌이 들었고, 위태로운 다리에 지식을 쌓고 있다는 생각이 들곤 했다. 수학을 어디서부터 다시 배워야 할 지 몰라 망설이고 있을 때, MIT 대학의 수업인 &amp;ldquo;Mathematics For Computer Science&amp;quot;를 발견했다. 이 수업을 시작으로 차근차근 수학적 지식을 쌓아보려고 한다. 참고로 &lt;a class=&#34;link&#34; href=&#34;https://ocw.mit.edu/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OpenCourseWare&lt;/a&gt;에 &lt;a class=&#34;link&#34; href=&#34;https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/pages/syllabus/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;6.042J&lt;/a&gt;로 등록된 수업으로 온라인 강의와 거의 교재 수준으로 작성된 강의 노트를 누구나 열람할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;명제-proposition&#34;&gt;명제 (Proposition)&lt;/h2&gt;
&lt;p&gt;명제(Proposition)는 참(true) 혹은 거짓(false)이 될 수 있는 서술문(statement)를 의미한다. 예를 들어 &lt;code&gt;1+1 = 2&lt;/code&gt;  식이나 &lt;code&gt;모든 사람은 생각한다&lt;/code&gt; 라는 문장이 proposition이라고 말할 수 있다. 반면에 참, 거짓으로 이어지지 않는 &lt;code&gt;사람은 왜 죽을까?&lt;/code&gt;라는 문장은 proposition에 속하지 않는다.&lt;/p&gt;
&lt;h3 id=&#34;ambiguity&#34;&gt;Ambiguity&lt;/h3&gt;
&lt;p&gt;우리가 일상 생활에서 쓰는 문장과 말은 논리적으로 참, 거짓을 따지기 모호한 경우가 많다. &lt;code&gt;한국인은 대부분 오른손잡이다&lt;/code&gt; 라는 문장에서 &amp;ldquo;대부분&amp;quot;이라는 말은 정확히 전체 한국인 중 얼마의 비율을 의미할까? 그리고 오른손잡이는 오른손은 &amp;ldquo;주로&amp;rdquo; 사용하는 사람이라는 뜻인데, 하루에 오른손 사용 빈도가 50%가 넘으면 오른손 잡이라고 하면 될까? 사실 일반적인 대화에서는 대화의 문맥이나 사회적인 통념 등에 의해 구구절절 정확한 표현을 따지지 않아도 충분히 의사소통이 가능하다.&lt;/p&gt;
&lt;p&gt;하지만 수학에서 모호함은 허용되지 않는다. 개인에 견해에 따라 해석이 달라질 수 있는 단어와 표현을 배제하고 논리정연하게 서술된 문장만이 참과 거짓을 논할 수 있는 것이다. 문장의 의미가 정확히 정의되지도 않았는데 참과 거짓을 논한다는 것 자체가 모순이다. 그래서 수학자들은 일상 생활에서 사용하는 &amp;ldquo;모든&amp;rdquo;, &amp;ldquo;일부&amp;rdquo;, &amp;ldquo;또는&amp;rdquo;, &amp;ldquo;그리고&amp;rdquo; 등의 모호한 단어를 전부 명확히 정의하고 기호로 표시하여 대화한다.&lt;/p&gt;
&lt;h2 id=&#34;imply&#34;&gt;Imply&lt;/h2&gt;
&lt;p&gt;P이면 Q이다, if P then Q 처럼 두 개의 proposition을 가정과 결론의 논리적인 관계로 나타날 때 imply를 사용하고 P-&amp;gt;Q로 표현한다. imply는 proposition이나 일상 용법에도 흔히 나타나는 용법이지만, 직관적이지 않은 부분이 있어 따로 얘기할 만한 내용이 있다. 우선 imply의 진리표는 다음과 같다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;P&lt;/th&gt;
&lt;th&gt;Q&lt;/th&gt;
&lt;th&gt;P implies Q&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;ldquo;리만 가설이 참이라면, 모든 실수 x에 대해 x&lt;sup&gt;2&lt;/sup&gt;는 0보다 크다.&amp;rdquo; 라는 문장은 &amp;ldquo;리만 가설이 참이라면&amp;quot;가 가정 P, &amp;ldquo;모든 실수에 대해 x&lt;sup&gt;2&lt;/sup&gt;는 0보다 크다&amp;quot;라는 결론 Q가 P implies Q 형태를 이루는 proposition이다. 리만 가설은 아직까지 참/거짓이 증명되지 않은 유명한 밀레니엄 문제라 참/거짓을 알 수 없지만, &amp;ldquo;모든 실수에 대해 x&lt;sup&gt;2&lt;/sup&gt;는 0보다 크다&amp;quot;라는 proposition은 이미 참으로 증명된 사실이다. 진리표에 따르면 가정 P의 참/거짓 유무에 상관없이 결론 Q가 참이면 결국 참이므로 해당 proposition은 참이다.&lt;/p&gt;
&lt;p&gt;결론 Q가 참인 경우에는 결국 결론이 맞는 말이니 proposition 자체가 맞다고 직관적으로 생각할 수 있지만, 가정 P와 결론 Q 모두 거짓인 proposition도 참인 것은 직관적이지 않다. 어느 한 드라마에서 여주가 남주에게 &amp;ldquo;네가 외계인이면 난 뱀파이어다&amp;rdquo; 라고 말하는 장면이 나온다. 이 문장을 proposition으로 본다면, 가정과 결론 모두 거짓이라 참인 proposition이 된다. (물론 드라마에선 남주가 외계인이라는 가정이 참이였다..) 일생 생활에서 우리는 &amp;ldquo;너가 뱀파이어일 리가 없다&amp;quot;라는 부정의 의미로 반어법을 사용해서 더욱 직관적이지 않아 보이는 것 같다.&lt;/p&gt;
&lt;p&gt;논리적으로 따져보면 가정 명제부터 거짓이라면 결론 명제에 대한 참/거짓을 판단할 수 없다. 하지만 proposition에서 참 혹은 거짓 이외의 &amp;ldquo;모름&amp;rdquo;, &amp;ldquo;알 수 없음&amp;rdquo; 등의 답은 존재하지 않는다. 때문에 수학자들은 가정이 거짓이라면 결론과 상관없이 참으로 결론을 지었다. 여기서 나는 거짓으로 결론 짓는게 더 직관적인데 왜 참으로 정한건 지 이해가 가지 않았는데, 한 블로그 &lt;a class=&#34;link&#34; href=&#34;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=kyj0833&amp;amp;logNo=220990303979&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;포스트&lt;/a&gt;를 보고 이해가 갔다. &amp;ldquo;P이면 P이다&amp;rdquo; 라는 명제는 직관적으로 참으로 여겨진다. 근데 수학자들이 가정 P가 거짓인 경우 거짓 명제인 거로 정했다면 &amp;ldquo;P이면 P이다&amp;rdquo; 라는 명제를 거짓으로 봐야하는 모순적인 상황이 발생한다. 일상 생활에서 직관적이지 않을 수 있지만, 수학에서는 오히려 직관적으로 보이는 선택이였던 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결국 implication은 결론 Q가 참이거나 가정 P가 거짓인 경우 참이 되는 proposition이라고 정의할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;iff&#34;&gt;IFF&lt;/h2&gt;
&lt;p&gt;P if and only if Q 라는 proposition는 P와 Q가 논리적으로 동일한 관계를 나타낸다. 그래서 NXOR 과 진리표가 동일하고 P &amp;lt;-&amp;gt; Q로 표현한다. P-&amp;gt;Q 에서 Q는 P이기 위한 필요 조건(necessary condition)이고 P는 Q이기 위한 충분 조건(sufficient condition)이다. 서로가 서로에게 필요 조건인 동시에 충분 조건이므로 IFF 관계를 필요충분조건(necessary and sufficient condition)이라고도 부른다.&lt;/p&gt;
&lt;h2 id=&#34;predicates-and-quantifiers&#34;&gt;Predicates and Quantifiers&lt;/h2&gt;
&lt;p&gt;지금까지 예제로 나온 proposition는 모든 경우에 수에 대해 일일히 셀 수 있을 정도의 참/거짓을 판단하기 쉬웠지만, 가능한 모든 경우를 전부 확인하기 어려운 proposition도 많다. 예를 들어 &amp;ldquo;모든 음수가 아닌 숫자 n에 대해 p(n) = n&lt;sup&gt;2&lt;/sup&gt; + n + 41은 소수이다.&amp;rdquo; 라는 proposition에서 n&amp;lt;=39인 경우만 참이고 그 이후는 거짓이 된다. cf. &lt;code&gt;p(40) = 40*40 + 40 + 41 = 41&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;모든 ~에 대해(for all) 라는 표현은 기호로 All에서 A를 뒤집어 ∀ 기호로 표현한다. 그래서 위 proposition을 &lt;code&gt;∀n ∈ N. p(n) is prime&lt;/code&gt; 으로 깔끔하게 표현할 수 있다. 다른 예시로 &amp;ldquo;모든 양의 정수 a, b, c, d에 대해 a&lt;sup&gt;4&lt;/sup&gt; + b&lt;sup&gt;4&lt;/sup&gt; + c&lt;sup&gt;4&lt;/sup&gt;= d&lt;sup&gt;4&lt;/sup&gt;을 만족하는 해가 없다&amp;rdquo; 라는 proposition은 &amp;ldquo;∀a,b,c,d ∈ Z&lt;sup&gt;+&lt;/sup&gt;. a&lt;sup&gt;4&lt;/sup&gt; + b&lt;sup&gt;4&lt;/sup&gt; + c&lt;sup&gt;4&lt;/sup&gt;≠ d&lt;sup&gt;4&lt;/sup&gt;&amp;ldquo;라고 표현할 수 있다. 그리고 이 방정식에 대한 해는 1987년 Noam Elkies에 의해 발견되어 거짓인 proposition으로 판명났지만 218년이나 걸렸다.&lt;/p&gt;
&lt;p&gt;이와 비슷하게 무작위 값을 대입해서 확인하는 방식으로 대부분 경우에서 참인 결과가 나와도 우리가 예상치 못한 값으로 거짓으로 판명될 수 있다. 충분히 많은 경우의 수를 대입해서 모두 참이 나와도 결국 모든 경우의 수를 전부 확인하지 않는 이상 확신할 수 없다. 대부분 컴퓨터의 빠른 연산 능력을 통해 유한한 경우의 수를 시도해보지만, 결국 현대 기술로도 모든 경우의 수를 확인할 수는 없다. 그래서 증명은 수학의 꽃이라고 불릴 정도로 난해하고 신기한 영역이지 않을까 싶다.&lt;/p&gt;
&lt;h3 id=&#34;predicates&#34;&gt;Predicates&lt;/h3&gt;
&lt;p&gt;하나 이상의 변수에 의해 참/거짓이 결정되는 proposition을 predicate라고 부른다. 위 예시에서 봤던 &amp;ldquo;p(n) = n&lt;sup&gt;2&lt;/sup&gt; + n + 41은 소수이다.&amp;ldquo;가 predicate에 속하는 것이다.&lt;/p&gt;
&lt;h3 id=&#34;quantifier&#34;&gt;Quantifier&lt;/h3&gt;
&lt;p&gt;변수에 따라 참/거짓 여부가 달라지는 predicate는 모든 경우에 대해 참일 수도 있고, 몇몇 경우에 대해서만 참일 수 있다. 이렇게 predicate가 참이 되는 빈도수를 모호함 없이 수학적으로 정확히 표현할 때 사용하는게 quantifier이다. 모든 경우에 대해 항상 참이 될 때 사용하는 quantifier를 Universal quantification라고 부르며 ∀ 기호로 표현한다. 몇몇 경우에 대해서만 참이 될 때 사용하는 quantifier는 Existential quantification라고 부르며 ∃ 기호로 표현한다. Existential quantification는 보통 참인 경우가 존재한다(there exists)라고 읽으므로 E를 뒤집은 기호를 사용한다.&lt;/p&gt;
&lt;p&gt;predicate에서 quantifier가 여러 개일 수도 있다. 예를 들어 &amp;ldquo;2보다 큰 모든 짝수는 두 소수의 합이다.&amp;rdquo; 라는 predicate를 좀 더 명확한 표현으로 바꾸면 &amp;ldquo;모든 2보다 큰 짝수 n에 대해 n = p+q를 만족하는 소수 p, q가 존재한다.&amp;ldquo;가 된다. 기호를 이용하면 더욱 간결하게 표현할 수 있다. &lt;code&gt;∀n ∈ Evens. ∃p,q ∈ Primes. n = p+q&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;order-of-quantifiers&#34;&gt;Order of quantifiers&lt;/h3&gt;
&lt;p&gt;quantifier가 여러 개인 predicate는 순서에 따라 의미가 완전히 달라진다. 위에서 사용한 predicate의 quantifier 순서를 바꾸면  ∃p,q ∈ Primes. ∀n ∈ Evens. n = p+q 가 된다. 이를 해석하면 &amp;ldquo;소수인 p, q가 존재한다. 모든 짝수인 n에 대해 n=p+q가 항상 참이 되는.&amp;rdquo; 어순만 반대로고 달라진게 없어보이지만, 이 문장이 의미하는 바는 소수인 p와 q의 합으로 모든 짝수를 만들 수 있는 마법의 p,q가 존재한다는 뜻이 된다.&lt;/p&gt;
&lt;h3 id=&#34;negating-quantifiers&#34;&gt;Negating Quantifiers&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;모든 사람이 피자를 좋아하는 것은 아니다.&amp;rdquo; 라는 문장과 &amp;ldquo;피자를 좋아하지 않는 사람도 있다.&amp;rdquo; 문장이 뜻하는 바는 같다. 기호로 표현하면 각각 &lt;code&gt;NOT(∀x. P(x))&lt;/code&gt;와 &lt;code&gt;∃x. NOT(P(X))&lt;/code&gt;으로 표현할 수 있고, 두 개의 식이 같다는 사실을 통해 quantifier에 부정 연산이 적용되면 ∀ -&amp;gt; ∃ 또는 반대로 바뀌는 것을 알 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;validity-and-satisfiability&#34;&gt;Validity and Satisfiability&lt;/h2&gt;
&lt;p&gt;여러 명제로 이루어진 논리식(Propositional formula)에서 모든 명제의 참/거짓 여부와 상관없이 항상 참이 될 때 타당(valid)한 명제라고 부른다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[P AND (Q OR R)] IFF [(P AND Q) OR (P AND R)]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 명제에서 P, Q, R에 대해 모든 경우의 수를 따져 진리표를 작성해보면 결국 &lt;code&gt;P AND (Q OR R)&lt;/code&gt;과 &lt;code&gt;(P AND  Q) OR (P AND R)&lt;/code&gt; 은 같은 식인 것을 알 수 있다. 이처럼 모든 경우에 수에 대해 참으로 판별된 명제는 타당하다고 말할 수 있다. 비슷하게 주어진 명제를 참으로 만드는 경우의 수가 하나라도 존재하는 경우가 존재하면 satisfiable하다고 말한다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Today I Learnd: 캡슐화(Encapsulation)</title>
        <link>https://truealarm.github.io/p/today-i-learnd-%EC%BA%A1%EC%8A%90%ED%99%94encapsulation/</link>
        <pubDate>Fri, 20 Jan 2023 14:36:42 +0900</pubDate>
        
        <guid>https://truealarm.github.io/p/today-i-learnd-%EC%BA%A1%EC%8A%90%ED%99%94encapsulation/</guid>
        <description>&lt;p&gt;기본적인 개념에 대한 글을 머리속으로 슥슥 읽으면 이해했다는 느낌을 받아도 막상 누군가에게 설명하려고 하면 쉽지 않다. 조리 있게 말하는 언어적 능력이나 논리정연하게 서술하는 것에 익숙하지 않아 그럴 수도 있지만, 완벽히 이해하지 못했을 가능성이 크다. 사실 어느 쪽이 문제인지 상관없이 다른 사람에게 어려운 개념을 이해하기 쉽게 설명할 수 있는 능력은 개발자에게 정말 중요하다고 생각한다. 가벼운 내용이라도 하루에 최소 한번 씩 오늘 읽은 글을 정리하고, 내 언어로 좀 더 쉽게 재가공해보려고 한다. 이번에는 Object-oriented programming 언어의 핵심 개념인 캡슐화(Encapsulation)를 다룬다.&lt;/p&gt;
&lt;h2 id=&#34;meaning&#34;&gt;Meaning&lt;/h2&gt;
&lt;p&gt;객체 지향 프로그래밍(Object-oriented programming) 언어에서 Encapsulation은 크게 2가지 의미를 내포한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터와 데이터를 조작하는 메소드를 하나의 객체로 전부 묶는 행위 (bundling)&lt;/li&gt;
&lt;li&gt;객체의 내부 요소(data or method)에 직접 접근하지 못하도록 막는 행위 (information hiding)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;첫 번째 의미인 bundling은 객체와 관련된 데이터(state)와 method는 전부 하나의 객체로 묶어서 객체 간 독립성과 응집도를 높이는 방법이다. 독립성과 응집도가 높아지면 요구 사항 변경으로 인한 코드 변경 시에도 최소한의 코드만 수정하면 된다. 예시로 Class에서 멤버 변수와 멤버 함수를 정의하는게 bundling이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;두 번째 의미인 information hiding은 객체의 내부 데이터와 method는 객체 내부에서만 접근 가능하고, 외부에서는 공개된 interface를 통해서 접근을 허용하는 방법을 말한다. 그래서 데이터에 접근하거나 변경할 때 객체의 내부 구현체를 살펴보지 않아도 되고, 공개된 interface 정보만 살펴보면 된다. 또한 interface를 통해 제공하는 getter, setter로 데이터에 접근하면 의도치 않은 값으로 변경되는 것을 막을 수 있는 Defensive 프로그래밍이 가능하며 이는 프로그램의 견고함(robustness)을 높여준다. 예시로 Java, C++에서는 접근 제어 지시자인 private, public으로, 파이썬은 name mangling으로 내부 데이터로 직접 접근을 막는다. 그리고 외부로 공개하는 interface나 헤더 파일로 내부 구현체에 대한 정보를 은닉한다.&lt;/p&gt;
&lt;h2 id=&#34;side-notes&#34;&gt;Side notes&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Information hiding은 Encapsulation이 아니다&lt;/a&gt; 라고 주장하는 전문가도 있고, bundling과 information hiding 모두 Encapsulation에 포함되는 개념이라고 보는 전문가도 있다. 나는 두 개념 모두 내포하고 있는 개념이라고 본다..&lt;/li&gt;
&lt;li&gt;OOP 언어로 고안된 언어가 아닌 C 언어에서도 &lt;code&gt;extern&lt;/code&gt; 키워드를 사용하고 헤더 파일을 분리하는 방식으로 Encapsulation이 가능하다. 이처럼 Encapsulation은 OOP에만 국한된 개념은 절대 아니다.&lt;/li&gt;
&lt;li&gt;Encapsulation과 마찬가지로 OOP의 대표적인 특성 중 하나인 상속(Inheritance)은 종종 Encapsulation을 해칠 수 있다. 특히 has-a 관계에서 상속을 사용하면 부모의 모든 데이터와 메소드를 물려받기 때문에 자식은 필요없는 정보까지 신경써야 되고, 이는 난잡한 bundling으로 귀결되곤 한다. 관련해서는 Inheritance에 대해 공부하면서 한번 더 정리할 예정이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cl.cam.ac.uk/teaching/0910/OOProg/lectures_annotated.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cl.cam.ac.uk/teaching/0910/OOProg/lectures_annotated.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
